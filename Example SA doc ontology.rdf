<?xml version="1.0"?>


<!DOCTYPE rdf:RDF [
    <!ENTITY owl "http://www.w3.org/2002/07/owl#" >
    <!ENTITY view "http://localhost/ontowiki/view/" >
    <!ENTITY xsd "http://www.w3.org/2001/XMLSchema#" >
    <!ENTITY owl2xml "http://www.w3.org/2006/12/owl2-xml#" >
    <!ENTITY ontowiki_WikiPage "http://localhost/ontowiki_WikiPage/" >
    <!ENTITY rdfs "http://www.w3.org/2000/01/rdf-schema#" >
    <!ENTITY rdf "http://www.w3.org/1999/02/22-rdf-syntax-ns#" >
    <!ENTITY UvA-SA-ontology "http://www.archimind.org/archimind/UvA-SA-ontology.owl#" >
    <!ENTITY Ontology1308582601209 "http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#" >
    <!ENTITY Ontology1288790966584 "http://www.semanticweb.org/ontologies/2010/10/Ontology1288790966584.owl#" >
    <!ENTITY Ontology13085826012098 "http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#8" >
    <!ENTITY Ontology130858260120913 "http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#9" >
    <!ENTITY Ontology130858260120911 "http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#6" >
    <!ENTITY Ontology130858260120915 "http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#7" >
    <!ENTITY Ontology130858260120912 "http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#4" >
    <!ENTITY Ontology130858260120914 "http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#5" >
    <!ENTITY Ontology130858260120921 "http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#2" >
    <!ENTITY Ontology13085826012095 "http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#3" >
    <!ENTITY Ontology130858260120920 "http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#1" >
    <!ENTITY Ontology13085826012092 "http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#15" >
    <!ENTITY Ontology130858260120925 "http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#16" >
    <!ENTITY Ontology130858260120916 "http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#17" >
    <!ENTITY Ontology130858260120924 "http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#18" >
    <!ENTITY Ontology130858260120919 "http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#11" >
    <!ENTITY Ontology130858260120923 "http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#12" >
    <!ENTITY Ontology13085826012099 "http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#13" >
    <!ENTITY Ontology13085826012094 "http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#14" >
    <!ENTITY Ontology130858260120922 "http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#19" >
    <!ENTITY Ontology130858260120910 "http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#26" >
    <!ENTITY Ontology130858260120918 "http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#24" >
    <!ENTITY Ontology130858260120917 "http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#22" >
    <!ENTITY Ontology13085826012097 "http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#23" >
    <!ENTITY Ontology13085826012093 "http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#21" >
    <!ENTITY Ontology13085826012096 "http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#20" >
]>


<rdf:RDF xmlns="http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#"
     xml:base="http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl"
     xmlns:Ontology1308582601209="http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#"
     xmlns:UvA-SA-ontology="http://www.archimind.org/archimind/UvA-SA-ontology.owl#"
     xmlns:Ontology130858260120913="&Ontology1308582601209;9"
     xmlns:Ontology130858260120914="&Ontology1308582601209;5"
     xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#"
     xmlns:Ontology130858260120915="&Ontology1308582601209;7"
     xmlns:Ontology130858260120916="&Ontology1308582601209;17"
     xmlns:owl2xml="http://www.w3.org/2006/12/owl2-xml#"
     xmlns:Ontology1288790966584="http://www.semanticweb.org/ontologies/2010/10/Ontology1288790966584.owl#"
     xmlns:ontowiki_WikiPage="http://localhost/ontowiki_WikiPage/"
     xmlns:Ontology130858260120910="&Ontology1308582601209;26"
     xmlns:Ontology130858260120911="&Ontology1308582601209;6"
     xmlns:Ontology130858260120912="&Ontology1308582601209;4"
     xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
     xmlns:Ontology13085826012098="&Ontology1308582601209;8"
     xmlns:Ontology130858260120919="&Ontology1308582601209;11"
     xmlns:Ontology13085826012099="&Ontology1308582601209;13"
     xmlns:Ontology130858260120917="&Ontology1308582601209;22"
     xmlns:Ontology13085826012096="&Ontology1308582601209;20"
     xmlns:Ontology13085826012097="&Ontology1308582601209;23"
     xmlns:Ontology130858260120918="&Ontology1308582601209;24"
     xmlns:Ontology13085826012094="&Ontology1308582601209;14"
     xmlns:Ontology13085826012095="&Ontology1308582601209;3"
     xmlns:Ontology13085826012092="&Ontology1308582601209;15"
     xmlns:Ontology13085826012093="&Ontology1308582601209;21"
     xmlns:xsd="http://www.w3.org/2001/XMLSchema#"
     xmlns:Ontology130858260120923="&Ontology1308582601209;12"
     xmlns:owl="http://www.w3.org/2002/07/owl#"
     xmlns:Ontology130858260120922="&Ontology1308582601209;19"
     xmlns:Ontology130858260120921="&Ontology1308582601209;2"
     xmlns:view="http://localhost/ontowiki/view/"
     xmlns:Ontology130858260120920="&Ontology1308582601209;1"
     xmlns:Ontology130858260120925="&Ontology1308582601209;16"
     xmlns:Ontology130858260120924="&Ontology1308582601209;18">
    <owl:Ontology rdf:about="http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl">
        <rdfs:label>Architecture Knowledge Domain Ontology</rdfs:label>
    </owl:Ontology>
    


    <!-- 
    ///////////////////////////////////////////////////////////////////////////////////////
    //
    // Annotation properties
    //
    ///////////////////////////////////////////////////////////////////////////////////////
     -->

    


    <!-- 
    ///////////////////////////////////////////////////////////////////////////////////////
    //
    // Datatypes
    //
    ///////////////////////////////////////////////////////////////////////////////////////
     -->

    


    <!-- http://www.w3.org/2001/XMLSchema#date -->

    <rdfs:Datatype rdf:about="&xsd;date"/>
    


    <!-- 
    ///////////////////////////////////////////////////////////////////////////////////////
    //
    // Object Properties
    //
    ///////////////////////////////////////////////////////////////////////////////////////
     -->

    


    <!-- http://www.archimind.org/archimind/UvA-SA-ontology.owl#based_on -->

    <owl:ObjectProperty rdf:about="&UvA-SA-ontology;based_on">
        <rdfs:label>assumes</rdfs:label>
        <rdfs:comment>&lt;decision / option&gt; assumes an &lt; assumption&gt;
Assumptions support detailed rationale for design options.
These are axioms from which design issues are addressed</rdfs:comment>
        <rdfs:domain rdf:resource="&UvA-SA-ontology;Design_Alternatives"/>
    </owl:ObjectProperty>
    


    <!-- http://www.archimind.org/archimind/UvA-SA-ontology.owl#communicates_with -->

    <owl:ObjectProperty rdf:about="&UvA-SA-ontology;communicates_with">
        <rdfs:label>communicates with</rdfs:label>
        <rdfs:comment>[architectural element or stakeholder] communicates with [architectural element or stakeholder]
Denotes communication between architectural elements and denotes communication of stakeholders (users, developers) with specific architectural elements</rdfs:comment>
        <rdfs:domain rdf:resource="&UvA-SA-ontology;Architecture"/>
        <rdfs:domain rdf:resource="&UvA-SA-ontology;Stakeholder"/>
    </owl:ObjectProperty>
    


    <!-- http://www.archimind.org/archimind/UvA-SA-ontology.owl#compromises_of -->

    <owl:ObjectProperty rdf:about="&UvA-SA-ontology;compromises_of">
        <rdfs:label>compromises of</rdfs:label>
        <rdfs:comment>&lt;composes&gt; - relate an architectural element to the components contained or compised in that element.
denotes structural decomposition</rdfs:comment>
        <rdfs:domain rdf:resource="&UvA-SA-ontology;Subsystem"/>
    </owl:ObjectProperty>
    


    <!-- http://www.archimind.org/archimind/UvA-SA-ontology.owl#concerned_about -->

    <owl:ObjectProperty rdf:about="&UvA-SA-ontology;concerned_about">
        <rdfs:label>concerned about</rdfs:label>
        <rdfs:comment>&lt;stakeholder&gt; is concerned about &lt;requirment&gt;
This links the stakeholders to the requirements that they have specially mentioned to the architect team. These are leading/essential for a proper architectural solution that is fit to the stakeholders needs.</rdfs:comment>
        <rdfs:domain rdf:resource="&UvA-SA-ontology;Requirement"/>
        <rdfs:domain rdf:resource="&UvA-SA-ontology;Stakeholder"/>
    </owl:ObjectProperty>
    


    <!-- http://www.archimind.org/archimind/UvA-SA-ontology.owl#contains_knowledge_about -->

    <owl:ObjectProperty rdf:about="&UvA-SA-ontology;contains_knowledge_about">
        <rdfs:label>contains knowledge about</rdfs:label>
        <rdfs:comment>[WIkipage] contains knowledge about [architecture, requirements, design issues, stakeholders, etc..]
This denotes the location of knowledge in Wikipage that concern the Software Architecture and system described in a Architecture Document. Wikipages contain sections and topics from the Architecture Document</rdfs:comment>
        <rdfs:domain rdf:resource="&UvA-SA-ontology;WikiPage"/>
    </owl:ObjectProperty>
    


    <!-- http://www.archimind.org/archimind/UvA-SA-ontology.owl#decision_is_about -->

    <owl:ObjectProperty rdf:about="&UvA-SA-ontology;decision_is_about">
        <rdfs:label>is about</rdfs:label>
        <rdfs:comment>[design issue] &lt;is about&gt; [architectural element]  
This helps in identifying architectural elements that are impacted by a design issue, but not the direct result of it. E.g. to support change impact and downstream design.</rdfs:comment>
        <rdfs:domain rdf:resource="&Ontology1308582601209;Design_issue"/>
    </owl:ObjectProperty>
    


    <!-- http://www.archimind.org/archimind/UvA-SA-ontology.owl#depends_on -->

    <owl:ObjectProperty rdf:about="&UvA-SA-ontology;depends_on">
        <rdfs:label>depends on</rdfs:label>
        <rdfs:comment>relates [desig issues] to [requirements].
This denotes that the existence of a requirement or design issue depends on one or more other design issues or requirements. I.e. without the requirements the decision could be different and without the decion the requirement would not have to exist.
This related design issues to the requirements where they originate from (i.e. a design issue can be introduced by a requirement). 
Vice versa a requirement can depend on a design issue (e.g. functional: the system must exhibit functionality because that is the decision resulting from the design issue)</rdfs:comment>
        <rdfs:domain rdf:resource="&UvA-SA-ontology;Requirement"/>
        <rdfs:domain rdf:resource="&Ontology1308582601209;Design_issue"/>
    </owl:ObjectProperty>
    


    <!-- http://www.archimind.org/archimind/UvA-SA-ontology.owl#gathers_data -->

    <owl:ObjectProperty rdf:about="&UvA-SA-ontology;gathers_data">
        <rdfs:label>gathers data from</rdfs:label>
        <rdfs:comment>&lt;component&gt; gathers data from &lt; data store / tool&gt;</rdfs:comment>
        <rdfs:domain rdf:resource="&UvA-SA-ontology;Architecture"/>
    </owl:ObjectProperty>
    


    <!-- http://www.archimind.org/archimind/UvA-SA-ontology.owl#hosted_on -->

    <owl:ObjectProperty rdf:about="&UvA-SA-ontology;hosted_on">
        <rdfs:label>hosted on</rdfs:label>
        <rdfs:comment>&lt;layer / data store&gt; is hosted on &lt;server&gt;
Denotes deployment of architectural elements</rdfs:comment>
        <rdfs:domain rdf:resource="&UvA-SA-ontology;Architecture"/>
    </owl:ObjectProperty>
    


    <!-- http://www.archimind.org/archimind/UvA-SA-ontology.owl#hosts -->

    <owl:ObjectProperty rdf:about="&UvA-SA-ontology;hosts">
        <rdfs:label>hosts</rdfs:label>
        <rdfs:comment>Server &lt;hosts&gt; &lt;data store or layer&gt;
Denotes deployment of architectural elements</rdfs:comment>
        <rdfs:domain rdf:resource="&UvA-SA-ontology;Architecture"/>
    </owl:ObjectProperty>
    


    <!-- http://www.archimind.org/archimind/UvA-SA-ontology.owl#is_concern_of -->

    <owl:ObjectProperty rdf:about="&UvA-SA-ontology;is_concern_of">
        <rdfs:label>is concern of</rdfs:label>
        <rdfs:comment>&lt;requirement&gt; is concern of &lt;stakeholder&gt;
This links the stakeholders to the requirements that they have specially mentioned to the architect team. These are leading/essential for a proper architectural solution that is fit to the stakeholders needs.</rdfs:comment>
        <rdfs:domain rdf:resource="&UvA-SA-ontology;Requirement"/>
        <rdfs:domain rdf:resource="&UvA-SA-ontology;Stakeholder"/>
    </owl:ObjectProperty>
    


    <!-- http://www.archimind.org/archimind/UvA-SA-ontology.owl#is_modeled_in -->

    <owl:ObjectProperty rdf:about="&UvA-SA-ontology;is_modeled_in">
        <rdfs:label>is modeled in</rdfs:label>
        <rdfs:comment>&lt;architectural element&gt; is modeled in &lt;diagram&gt;
Diagrams model different architectural elements. E.g. structural decomposition of layers and components, behaviour, etc...</rdfs:comment>
        <rdfs:domain rdf:resource="&owl;Thing"/>
    </owl:ObjectProperty>
    


    <!-- http://www.archimind.org/archimind/UvA-SA-ontology.owl#knowledge_is_located_in -->

    <owl:ObjectProperty rdf:about="&UvA-SA-ontology;knowledge_is_located_in">
        <rdfs:label>knowledge is located in</rdfs:label>
        <rdfs:comment>&lt;Knowledge&gt; about [architecture, requirements, design issues, stakeholders, etc..] &lt;is located in&gt; [WIkipage] 
Location of knowledge in Wikipage about this Software Architecture and system described in a Architecture Document. Wikipages contain sections and topics from the Architecture Document</rdfs:comment>
        <rdfs:domain rdf:resource="&owl;Thing"/>
    </owl:ObjectProperty>
    


    <!-- http://www.archimind.org/archimind/UvA-SA-ontology.owl#made_for -->

    <owl:ObjectProperty rdf:about="&UvA-SA-ontology;made_for">
        <rdfs:label>assumed for</rdfs:label>
        <rdfs:comment>&lt;assumption&gt; is assumed for &lt;decision / option&gt;
Assumptions support detailed rationale for design options.
These are axioms from which design issues are addressed</rdfs:comment>
        <rdfs:domain rdf:resource="&UvA-SA-ontology;Design_Alternatives"/>
    </owl:ObjectProperty>
    


    <!-- http://www.archimind.org/archimind/UvA-SA-ontology.owl#models -->

    <owl:ObjectProperty rdf:about="&UvA-SA-ontology;models">
        <rdfs:label>models</rdfs:label>
        <rdfs:comment>&lt;diagram&gt; models &lt;architecture&gt;
Diagrams model different architectural elements. E.g. structural decomposition of layers and components, behaviour, etc...</rdfs:comment>
        <rdfs:domain rdf:resource="&UvA-SA-ontology;Architecture"/>
        <rdfs:domain rdf:resource="&UvA-SA-ontology;Diagram"/>
    </owl:ObjectProperty>
    


    <!-- http://www.archimind.org/archimind/UvA-SA-ontology.owl#part_of -->

    <owl:ObjectProperty rdf:about="&UvA-SA-ontology;part_of">
        <rdfs:label>part of</rdfs:label>
        <rdfs:comment>&lt;component&gt; is part of &lt;subsystem&gt;
denotes structural decomposition</rdfs:comment>
        <rdfs:domain rdf:resource="&UvA-SA-ontology;Component"/>
    </owl:ObjectProperty>
    


    <!-- http://www.archimind.org/archimind/UvA-SA-ontology.owl#posit_design -->

    <owl:ObjectProperty rdf:about="&UvA-SA-ontology;posit_design">
        <rdfs:label>has alternative</rdfs:label>
        <rdfs:comment>&lt;has alternative&gt; relates a desig issue to possible options to address the issue,</rdfs:comment>
        <rdfs:domain rdf:resource="&Ontology1308582601209;Design_issue"/>
    </owl:ObjectProperty>
    


    <!-- http://www.archimind.org/archimind/UvA-SA-ontology.owl#presented_in -->

    <owl:ObjectProperty rdf:about="&UvA-SA-ontology;presented_in">
        <rdfs:label>presented in</rdfs:label>
        <rdfs:comment>[architectural elements] are presented in a [view] from a certain viewpoint.
I.e. the architecture is viewed upon, in order to give a description relevant for stakeholders interested in that view</rdfs:comment>
        <rdfs:domain rdf:resource="&UvA-SA-ontology;Architecture"/>
        <rdfs:domain rdf:resource="&UvA-SA-ontology;View"/>
    </owl:ObjectProperty>
    


    <!-- http://www.archimind.org/archimind/UvA-SA-ontology.owl#presents -->

    <owl:ObjectProperty rdf:about="&UvA-SA-ontology;presents">
        <rdfs:label>presents</rdfs:label>
        <rdfs:comment>A &lt;view&gt; (re)presents [architectural elements] from a certain viewpoint. 
I.e. the architecture is viewed upon, in order to give a description relevant for stakeholders interested in that view</rdfs:comment>
        <rdfs:domain rdf:resource="&UvA-SA-ontology;Architecture"/>
        <rdfs:domain rdf:resource="&UvA-SA-ontology;View"/>
    </owl:ObjectProperty>
    


    <!-- http://www.archimind.org/archimind/UvA-SA-ontology.owl#realized_by -->

    <owl:ObjectProperty rdf:about="&UvA-SA-ontology;realized_by">
        <rdfs:label>realized by</rdfs:label>
        <rdfs:comment>&lt;realized_by&gt; links the (internal) architecture and requirements.
Spefic architectural elements can realize one or more requirements</rdfs:comment>
        <rdfs:domain rdf:resource="&UvA-SA-ontology;Requirement"/>
        <rdfs:domain rdf:resource="&Ontology1308582601209;Design_issue"/>
    </owl:ObjectProperty>
    


    <!-- http://www.archimind.org/archimind/UvA-SA-ontology.owl#related_to -->

    <owl:ObjectProperty rdf:about="&UvA-SA-ontology;related_to">
        <rdfs:label>related to</rdfs:label>
        <rdfs:comment>[requirement] is related to [requirement] denotes relationships between requirements such as: &#39;requirements are partially about the same functionality, user interaction or quality attributes&#39; or &#39;QA&#39;s influence each other&#39;
For example: 
&#39;development time is related to development cost&#39;,
&#39;reliability is related to availability&#39;</rdfs:comment>
        <rdfs:domain rdf:resource="&UvA-SA-ontology;Requirement"/>
    </owl:ObjectProperty>
    


    <!-- http://www.archimind.org/archimind/UvA-SA-ontology.owl#results_in -->

    <owl:ObjectProperty rdf:about="&UvA-SA-ontology;results_in">
        <rdfs:label>results in</rdfs:label>
        <rdfs:comment>&lt;results_in&gt; relates a [design issue] to an [architectural element] that is the result (of the decision on the design issue)
This helps in identifying architectural elements that are the direct result of it. E.g. to support change impact and downstream design.
&lt;results_in&gt; can also relate a [requirement] to an [architectural element] that is the result of a [design decision] that addresses the requirement.</rdfs:comment>
        <rdfs:domain rdf:resource="&UvA-SA-ontology;Architecture"/>
        <rdfs:domain rdf:resource="&Ontology1308582601209;Design_issue"/>
    </owl:ObjectProperty>
    


    <!-- http://www.archimind.org/archimind/UvA-SA-ontology.owl#satisfies -->

    <owl:ObjectProperty rdf:about="&UvA-SA-ontology;satisfies">
        <rdfs:label>satisfies</rdfs:label>
        <rdfs:comment>&lt;satisfies&gt; is to show that the architecture is satisfies certain requirements
Spefic architectural elements can satisfy one or more requirements</rdfs:comment>
        <rdfs:domain rdf:resource="&UvA-SA-ontology;Architecture"/>
        <rdfs:domain rdf:resource="&UvA-SA-ontology;Requirement"/>
    </owl:ObjectProperty>
    


    <!-- http://www.archimind.org/archimind/UvA-SA-ontology.owl#stores_data -->

    <owl:ObjectProperty rdf:about="&UvA-SA-ontology;stores_data">
        <rdfs:label>stores data in</rdfs:label>
        <rdfs:comment>&lt;component&gt; stores data in &lt;data store &gt;</rdfs:comment>
    </owl:ObjectProperty>
    


    <!-- http://www.archimind.org/archimind/UvA-SA-ontology.owl#supported_by -->

    <owl:ObjectProperty rdf:about="&UvA-SA-ontology;supported_by">
        <rdfs:label>supported by</rdfs:label>
        <rdfs:comment>&lt;design issue / option&gt; is supported by &lt;scenario&gt;
Scenarios can give arguments, background information or rationale for certain options and decisions on design issues</rdfs:comment>
        <rdfs:domain rdf:resource="&UvA-SA-ontology;Scenario"/>
    </owl:ObjectProperty>
    


    <!-- http://www.archimind.org/archimind/UvA-SA-ontology.owl#supports -->

    <owl:ObjectProperty rdf:about="&UvA-SA-ontology;supports">
        <rdfs:label>supports</rdfs:label>
        <rdfs:comment>&lt;Scenario&gt; supports &lt;design issue / Option&gt;
Scenarios can give arguments, background information or rationale for certain options and decisions on design issues</rdfs:comment>
        <rdfs:domain rdf:resource="&UvA-SA-ontology;Scenario"/>
    </owl:ObjectProperty>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Provided_by -->

    <owl:ObjectProperty rdf:about="&Ontology1308582601209;Provided_by">
        <rdfs:label>provided by</rdfs:label>
        <rdfs:comment>[behaviour] is provided by [component].
This denotes how behaviour is provided (or &#39;realized by&#39;) one component or multiple components that interact in order to achieve behaviour</rdfs:comment>
    </owl:ObjectProperty>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#addressed_by -->

    <owl:ObjectProperty rdf:about="&Ontology1308582601209;addressed_by">
        <rdfs:label>addressed by</rdfs:label>
        <rdfs:comment>A [requirement] is addressed by a [design issue] when that design issue considers the requirement and tries to balance it in its solution</rdfs:comment>
        <rdfs:domain rdf:resource="&UvA-SA-ontology;Requirement"/>
        <rdfs:domain rdf:resource="&Ontology1308582601209;Design_issue"/>
    </owl:ObjectProperty>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#offered_by -->

    <owl:ObjectProperty rdf:about="&Ontology1308582601209;offered_by">
        <rdfs:label>offered by</rdfs:label>
        <rdfs:comment>[API] is offered by [Layer]</rdfs:comment>
    </owl:ObjectProperty>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#offers -->

    <owl:ObjectProperty rdf:about="&Ontology1308582601209;offers">
        <rdfs:label>offers</rdfs:label>
        <rdfs:comment>[Layer] offers [API]</rdfs:comment>
    </owl:ObjectProperty>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#realizes -->

    <owl:ObjectProperty rdf:about="&Ontology1308582601209;realizes">
        <rdfs:label>provides</rdfs:label>
        <rdfs:comment>[component] provides [behaviour]
This denotes how behaviour is provides (or &#39;realized by&#39;) one component or multiple components that interact in order to achieve behaviour</rdfs:comment>
    </owl:ObjectProperty>
    


    <!-- 
    ///////////////////////////////////////////////////////////////////////////////////////
    //
    // Data properties
    //
    ///////////////////////////////////////////////////////////////////////////////////////
     -->

    


    <!-- http://localhost/ontowiki/view/released -->

    <owl:DatatypeProperty rdf:about="&view;released">
        <rdf:type rdf:resource="&owl;FunctionalProperty"/>
        <rdfs:label>released</rdfs:label>
        <rdfs:comment>Tells if this version of the Wikipage is released</rdfs:comment>
        <rdfs:domain rdf:resource="&UvA-SA-ontology;WikiPage"/>
        <rdfs:range rdf:resource="&xsd;string"/>
    </owl:DatatypeProperty>
    


    <!-- http://localhost/ontowiki_WikiPage/content -->

    <owl:DatatypeProperty rdf:about="&ontowiki_WikiPage;content">
        <rdf:type rdf:resource="&owl;FunctionalProperty"/>
        <rdfs:label>content</rdfs:label>
        <rdfs:comment>Content of WikiPage</rdfs:comment>
        <rdfs:domain rdf:resource="&UvA-SA-ontology;WikiPage"/>
        <rdfs:range rdf:resource="&xsd;string"/>
        <rdfs:domain rdf:resource="&owl;Thing"/>
    </owl:DatatypeProperty>
    


    <!-- http://www.archimind.org/archimind/UvA-SA-ontology.owl#Model -->

    <owl:DatatypeProperty rdf:about="&UvA-SA-ontology;Model">
        <rdf:type rdf:resource="&owl;FunctionalProperty"/>
        <rdfs:label rdf:datatype="&xsd;string">Model</rdfs:label>
        <rdfs:range rdf:resource="&xsd;string"/>
        <rdfs:domain rdf:resource="&owl;Thing"/>
    </owl:DatatypeProperty>
    


    <!-- http://www.archimind.org/archimind/UvA-SA-ontology.owl#Role -->

    <owl:DatatypeProperty rdf:about="&UvA-SA-ontology;Role">
        <rdf:type rdf:resource="&owl;FunctionalProperty"/>
        <rdfs:label>role</rdfs:label>
        <rdfs:domain rdf:resource="&UvA-SA-ontology;Stakeholder"/>
        <rdfs:range rdf:resource="&xsd;string"/>
    </owl:DatatypeProperty>
    


    <!-- http://www.archimind.org/archimind/UvA-SA-ontology.owl#arch_style -->

    <owl:DatatypeProperty rdf:about="&UvA-SA-ontology;arch_style">
        <rdf:type rdf:resource="&owl;FunctionalProperty"/>
        <rdfs:label rdf:datatype="&xsd;string">arch_style</rdfs:label>
        <rdfs:comment rdf:datatype="&xsd;string">describe the style, e.g. layer, modules, pipes, distributed</rdfs:comment>
        <rdfs:range rdf:resource="&xsd;string"/>
    </owl:DatatypeProperty>
    


    <!-- http://www.archimind.org/archimind/UvA-SA-ontology.owl#arguments -->

    <owl:DatatypeProperty rdf:about="&UvA-SA-ontology;arguments">
        <rdf:type rdf:resource="&owl;FunctionalProperty"/>
        <rdfs:label rdf:datatype="&xsd;string">arguments</rdfs:label>
        <rdfs:comment rdf:datatype="&xsd;string">this is the same as the design rationale, the pros and cons of an argument</rdfs:comment>
        <rdfs:domain rdf:resource="&Ontology1308582601209;Design_issue"/>
        <rdfs:range rdf:resource="&xsd;string"/>
    </owl:DatatypeProperty>
    


    <!-- http://www.archimind.org/archimind/UvA-SA-ontology.owl#author -->

    <owl:DatatypeProperty rdf:about="&UvA-SA-ontology;author">
        <rdf:type rdf:resource="&owl;FunctionalProperty"/>
        <rdfs:label>author</rdfs:label>
        <rdfs:comment>WikiPage author</rdfs:comment>
        <rdfs:domain rdf:resource="&UvA-SA-ontology;WikiPage"/>
        <rdfs:range rdf:resource="&xsd;string"/>
    </owl:DatatypeProperty>
    


    <!-- http://www.archimind.org/archimind/UvA-SA-ontology.owl#contributor -->

    <owl:DatatypeProperty rdf:about="&UvA-SA-ontology;contributor">
        <rdf:type rdf:resource="&owl;FunctionalProperty"/>
        <rdfs:label>contributor</rdfs:label>
        <rdfs:comment>An entity responsible for making contributions to the resource.</rdfs:comment>
        <rdfs:domain rdf:resource="&UvA-SA-ontology;WikiPage"/>
        <rdfs:range rdf:resource="&xsd;string"/>
        <rdfs:domain rdf:resource="&owl;Thing"/>
    </owl:DatatypeProperty>
    


    <!-- http://www.archimind.org/archimind/UvA-SA-ontology.owl#coverage -->

    <owl:DatatypeProperty rdf:about="&UvA-SA-ontology;coverage">
        <rdf:type rdf:resource="&owl;FunctionalProperty"/>
        <rdfs:label>coverage</rdfs:label>
        <rdfs:comment>The spatial or temporal topic of the resource, the spatial applicability of the resource, or the jurisdiction under which the resource is relevant.</rdfs:comment>
        <rdfs:domain rdf:resource="&UvA-SA-ontology;WikiPage"/>
        <rdfs:range rdf:resource="&xsd;string"/>
    </owl:DatatypeProperty>
    


    <!-- http://www.archimind.org/archimind/UvA-SA-ontology.owl#creator -->

    <owl:DatatypeProperty rdf:about="&UvA-SA-ontology;creator">
        <rdf:type rdf:resource="&owl;FunctionalProperty"/>
        <rdfs:label>creator</rdfs:label>
        <rdfs:comment>An entity primarily responsible for making the resource.</rdfs:comment>
        <rdfs:domain rdf:resource="&UvA-SA-ontology;WikiPage"/>
        <rdfs:range rdf:resource="&xsd;string"/>
        <rdfs:domain rdf:resource="&owl;Thing"/>
    </owl:DatatypeProperty>
    


    <!-- http://www.archimind.org/archimind/UvA-SA-ontology.owl#date -->

    <owl:DatatypeProperty rdf:about="&UvA-SA-ontology;date">
        <rdf:type rdf:resource="&owl;FunctionalProperty"/>
        <rdfs:label>date</rdfs:label>
        <rdfs:comment>A point or period of time associated with an event in the lifecycle of the resource.</rdfs:comment>
        <rdfs:domain rdf:resource="&UvA-SA-ontology;WikiPage"/>
        <rdfs:range rdf:resource="&xsd;date"/>
        <rdfs:range rdf:resource="&xsd;dateTime"/>
        <rdfs:range rdf:resource="&xsd;string"/>
    </owl:DatatypeProperty>
    


    <!-- http://www.archimind.org/archimind/UvA-SA-ontology.owl#decision_issue -->

    <owl:DatatypeProperty rdf:about="&UvA-SA-ontology;decision_issue">
        <rdf:type rdf:resource="&owl;FunctionalProperty"/>
        <rdfs:label rdf:datatype="&xsd;string">decision_issue</rdfs:label>
        <rdfs:comment rdf:datatype="&xsd;string">the issues of the decision</rdfs:comment>
        <rdfs:domain rdf:resource="&Ontology1308582601209;Design_issue"/>
        <rdfs:range rdf:resource="&xsd;string"/>
    </owl:DatatypeProperty>
    


    <!-- http://www.archimind.org/archimind/UvA-SA-ontology.owl#description -->

    <owl:DatatypeProperty rdf:about="&UvA-SA-ontology;description">
        <rdf:type rdf:resource="&owl;FunctionalProperty"/>
        <rdfs:label>description</rdfs:label>
        <rdfs:comment>An account of the resource.</rdfs:comment>
        <rdfs:range rdf:resource="&xsd;string"/>
        <rdfs:domain rdf:resource="&owl;Thing"/>
    </owl:DatatypeProperty>
    


    <!-- http://www.archimind.org/archimind/UvA-SA-ontology.owl#design_decision -->

    <owl:DatatypeProperty rdf:about="&UvA-SA-ontology;design_decision">
        <rdf:type rdf:resource="&owl;FunctionalProperty"/>
        <rdfs:label rdf:datatype="&xsd;string">design decision</rdfs:label>
        <rdfs:domain rdf:resource="&Ontology1308582601209;Design_issue"/>
        <rdfs:range rdf:resource="&xsd;string"/>
    </owl:DatatypeProperty>
    


    <!-- http://www.archimind.org/archimind/UvA-SA-ontology.owl#format -->

    <owl:DatatypeProperty rdf:about="&UvA-SA-ontology;format">
        <rdf:type rdf:resource="&owl;FunctionalProperty"/>
        <rdfs:label>format</rdfs:label>
        <rdfs:comment>The file format, physical medium, or dimensions of the resource.</rdfs:comment>
        <rdfs:range rdf:resource="&xsd;string"/>
    </owl:DatatypeProperty>
    


    <!-- http://www.archimind.org/archimind/UvA-SA-ontology.owl#identifier -->

    <owl:DatatypeProperty rdf:about="&UvA-SA-ontology;identifier">
        <rdf:type rdf:resource="&owl;FunctionalProperty"/>
        <rdfs:label>identifier</rdfs:label>
        <rdfs:comment>An unambiguous reference to the resource within a given context.</rdfs:comment>
        <rdfs:range rdf:resource="&xsd;string"/>
        <rdfs:domain rdf:resource="&owl;Thing"/>
    </owl:DatatypeProperty>
    


    <!-- http://www.archimind.org/archimind/UvA-SA-ontology.owl#language -->

    <owl:DatatypeProperty rdf:about="&UvA-SA-ontology;language">
        <rdf:type rdf:resource="&owl;FunctionalProperty"/>
        <rdfs:label>language</rdfs:label>
        <rdfs:comment>A language of the resource.</rdfs:comment>
        <rdfs:domain rdf:resource="&UvA-SA-ontology;WikiPage"/>
        <rdfs:range rdf:resource="&xsd;string"/>
    </owl:DatatypeProperty>
    


    <!-- http://www.archimind.org/archimind/UvA-SA-ontology.owl#name -->

    <owl:DatatypeProperty rdf:about="&UvA-SA-ontology;name">
        <rdf:type rdf:resource="&owl;FunctionalProperty"/>
        <rdfs:label rdf:datatype="&xsd;string">name</rdfs:label>
        <rdfs:range rdf:resource="&xsd;string"/>
        <rdfs:domain rdf:resource="&owl;Thing"/>
    </owl:DatatypeProperty>
    


    <!-- http://www.archimind.org/archimind/UvA-SA-ontology.owl#publisher -->

    <owl:DatatypeProperty rdf:about="&UvA-SA-ontology;publisher">
        <rdf:type rdf:resource="&owl;FunctionalProperty"/>
        <rdfs:label>publisher</rdfs:label>
        <rdfs:comment>An entity responsible for making the resource available.</rdfs:comment>
        <rdfs:domain rdf:resource="&UvA-SA-ontology;WikiPage"/>
        <rdfs:range rdf:resource="&xsd;string"/>
    </owl:DatatypeProperty>
    


    <!-- http://www.archimind.org/archimind/UvA-SA-ontology.owl#quality_attribute_measures -->

    <owl:DatatypeProperty rdf:about="&UvA-SA-ontology;quality_attribute_measures">
        <rdf:type rdf:resource="&owl;FunctionalProperty"/>
        <rdfs:label rdf:datatype="&xsd;string">quality_attribute_measures</rdfs:label>
        <rdfs:comment rdf:datatype="&xsd;string">Document specific measures and metrics of the quality requirements. E.g. U/I response time is 0.5s</rdfs:comment>
        <rdfs:domain rdf:resource="&UvA-SA-ontology;Non_functional_requirement"/>
        <rdfs:range rdf:resource="&xsd;string"/>
    </owl:DatatypeProperty>
    


    <!-- http://www.archimind.org/archimind/UvA-SA-ontology.owl#rights -->

    <owl:DatatypeProperty rdf:about="&UvA-SA-ontology;rights">
        <rdf:type rdf:resource="&owl;FunctionalProperty"/>
        <rdfs:label>rights</rdfs:label>
        <rdfs:comment>Information about rights held in and over the resource.</rdfs:comment>
        <rdfs:domain rdf:resource="&UvA-SA-ontology;WikiPage"/>
        <rdfs:range rdf:resource="&xsd;string"/>
    </owl:DatatypeProperty>
    


    <!-- http://www.archimind.org/archimind/UvA-SA-ontology.owl#source -->

    <owl:DatatypeProperty rdf:about="&UvA-SA-ontology;source">
        <rdf:type rdf:resource="&owl;FunctionalProperty"/>
        <rdfs:label>source</rdfs:label>
        <rdfs:comment>A related resource from which the described resource is derived. (e.g. URI/document)</rdfs:comment>
        <rdfs:domain rdf:resource="&UvA-SA-ontology;WikiPage"/>
        <rdfs:range rdf:resource="&xsd;string"/>
    </owl:DatatypeProperty>
    


    <!-- http://www.archimind.org/archimind/UvA-SA-ontology.owl#stakeholder_name -->

    <owl:DatatypeProperty rdf:about="&UvA-SA-ontology;stakeholder_name">
        <rdf:type rdf:resource="&owl;FunctionalProperty"/>
        <rdfs:label rdf:datatype="&xsd;string">stakeholder_name</rdfs:label>
        <rdfs:domain rdf:resource="&UvA-SA-ontology;Stakeholder"/>
        <rdfs:range rdf:resource="&xsd;string"/>
    </owl:DatatypeProperty>
    


    <!-- http://www.archimind.org/archimind/UvA-SA-ontology.owl#subject -->

    <owl:DatatypeProperty rdf:about="&UvA-SA-ontology;subject">
        <rdf:type rdf:resource="&owl;FunctionalProperty"/>
        <rdfs:label>subject</rdfs:label>
        <rdfs:comment>The topic of the resource.</rdfs:comment>
        <rdfs:domain rdf:resource="&UvA-SA-ontology;WikiPage"/>
        <rdfs:range rdf:resource="&xsd;string"/>
    </owl:DatatypeProperty>
    


    <!-- http://www.archimind.org/archimind/UvA-SA-ontology.owl#title -->

    <owl:DatatypeProperty rdf:about="&UvA-SA-ontology;title">
        <rdf:type rdf:resource="&owl;FunctionalProperty"/>
        <rdfs:label>title</rdfs:label>
        <rdfs:comment>A name given to the resource.</rdfs:comment>
        <rdfs:domain rdf:resource="&UvA-SA-ontology;WikiPage"/>
        <rdfs:range rdf:resource="&xsd;string"/>
    </owl:DatatypeProperty>
    


    <!-- http://www.archimind.org/archimind/UvA-SA-ontology.owl#type -->

    <owl:DatatypeProperty rdf:about="&UvA-SA-ontology;type">
        <rdf:type rdf:resource="&owl;FunctionalProperty"/>
        <rdfs:label>type</rdfs:label>
        <rdfs:comment>The nature or genre of the resource.</rdfs:comment>
        <rdfs:domain rdf:resource="&UvA-SA-ontology;WikiPage"/>
        <rdfs:range rdf:resource="&xsd;string"/>
    </owl:DatatypeProperty>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#status -->

    <owl:DatatypeProperty rdf:about="&Ontology1308582601209;status">
        <rdfs:label>status</rdfs:label>
        <rdfs:comment>status of an option decision: chosen or rejected</rdfs:comment>
    </owl:DatatypeProperty>
    


    <!-- 
    ///////////////////////////////////////////////////////////////////////////////////////
    //
    // Classes
    //
    ///////////////////////////////////////////////////////////////////////////////////////
     -->

    


    <!-- http://www.archimind.org/archimind/UvA-SA-ontology.owl#Architecture -->

    <owl:Class rdf:about="&UvA-SA-ontology;Architecture">
        <rdfs:label>Architecture</rdfs:label>
        <rdfs:subClassOf rdf:resource="&owl;Thing"/>
    </owl:Class>
    


    <!-- http://www.archimind.org/archimind/UvA-SA-ontology.owl#Assumption -->

    <owl:Class rdf:about="&UvA-SA-ontology;Assumption">
        <rdfs:label>Assumption</rdfs:label>
        <rdfs:subClassOf rdf:resource="&owl;Thing"/>
    </owl:Class>
    


    <!-- http://www.archimind.org/archimind/UvA-SA-ontology.owl#Component -->

    <owl:Class rdf:about="&UvA-SA-ontology;Component">
        <rdfs:label>Component</rdfs:label>
        <rdfs:subClassOf rdf:resource="&UvA-SA-ontology;Architecture"/>
    </owl:Class>
    


    <!-- http://www.archimind.org/archimind/UvA-SA-ontology.owl#Data_store -->

    <owl:Class rdf:about="&UvA-SA-ontology;Data_store">
        <rdfs:label>Data store</rdfs:label>
        <rdfs:subClassOf rdf:resource="&UvA-SA-ontology;Architecture"/>
    </owl:Class>
    


    <!-- http://www.archimind.org/archimind/UvA-SA-ontology.owl#Design_Alternatives -->

    <owl:Class rdf:about="&UvA-SA-ontology;Design_Alternatives">
        <rdfs:label>Option</rdfs:label>
        <rdfs:subClassOf rdf:resource="&owl;Thing"/>
    </owl:Class>
    


    <!-- http://www.archimind.org/archimind/UvA-SA-ontology.owl#Diagram -->

    <owl:Class rdf:about="&UvA-SA-ontology;Diagram">
        <rdfs:label>Diagram</rdfs:label>
        <rdfs:subClassOf rdf:resource="&owl;Thing"/>
    </owl:Class>
    


    <!-- http://www.archimind.org/archimind/UvA-SA-ontology.owl#Functional_requirement -->

    <owl:Class rdf:about="&UvA-SA-ontology;Functional_requirement">
        <rdfs:label>Functional requirement</rdfs:label>
        <rdfs:subClassOf rdf:resource="&UvA-SA-ontology;Requirement"/>
    </owl:Class>
    


    <!-- http://www.archimind.org/archimind/UvA-SA-ontology.owl#Non_functional_requirement -->

    <owl:Class rdf:about="&UvA-SA-ontology;Non_functional_requirement">
        <rdfs:label>Non-Functional Requirement</rdfs:label>
        <rdfs:subClassOf rdf:resource="&UvA-SA-ontology;Requirement"/>
        <rdfs:comment>AkA Quality Attribute</rdfs:comment>
    </owl:Class>
    


    <!-- http://www.archimind.org/archimind/UvA-SA-ontology.owl#Requirement -->

    <owl:Class rdf:about="&UvA-SA-ontology;Requirement">
        <rdfs:label>Requirement</rdfs:label>
        <rdfs:subClassOf rdf:resource="&owl;Thing"/>
    </owl:Class>
    


    <!-- http://www.archimind.org/archimind/UvA-SA-ontology.owl#Scenario -->

    <owl:Class rdf:about="&UvA-SA-ontology;Scenario">
        <rdfs:label>Scenario</rdfs:label>
        <rdfs:subClassOf rdf:resource="&owl;Thing"/>
    </owl:Class>
    


    <!-- http://www.archimind.org/archimind/UvA-SA-ontology.owl#Server -->

    <owl:Class rdf:about="&UvA-SA-ontology;Server">
        <rdfs:label>Server</rdfs:label>
        <rdfs:subClassOf rdf:resource="&UvA-SA-ontology;Architecture"/>
    </owl:Class>
    


    <!-- http://www.archimind.org/archimind/UvA-SA-ontology.owl#Stakeholder -->

    <owl:Class rdf:about="&UvA-SA-ontology;Stakeholder">
        <rdfs:label>Stakeholder</rdfs:label>
        <rdfs:subClassOf rdf:resource="&owl;Thing"/>
    </owl:Class>
    


    <!-- http://www.archimind.org/archimind/UvA-SA-ontology.owl#Subsystem -->

    <owl:Class rdf:about="&UvA-SA-ontology;Subsystem">
        <rdfs:label>Layer</rdfs:label>
        <rdfs:subClassOf rdf:resource="&UvA-SA-ontology;Architecture"/>
        <rdfs:comment>Layer is synonym for (AKA) &#39;subsystem&#39;</rdfs:comment>
    </owl:Class>
    


    <!-- http://www.archimind.org/archimind/UvA-SA-ontology.owl#Tool -->

    <owl:Class rdf:about="&UvA-SA-ontology;Tool">
        <rdfs:label>Tool Type</rdfs:label>
        <rdfs:subClassOf rdf:resource="&UvA-SA-ontology;Architecture"/>
    </owl:Class>
    


    <!-- http://www.archimind.org/archimind/UvA-SA-ontology.owl#View -->

    <owl:Class rdf:about="&UvA-SA-ontology;View">
        <rdfs:label>View</rdfs:label>
        <rdfs:subClassOf rdf:resource="&owl;Thing"/>
    </owl:Class>
    


    <!-- http://www.archimind.org/archimind/UvA-SA-ontology.owl#WikiPage -->

    <owl:Class rdf:about="&UvA-SA-ontology;WikiPage">
        <rdfs:label>WikiPage</rdfs:label>
        <rdfs:subClassOf rdf:resource="&owl;Thing"/>
    </owl:Class>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#API -->

    <owl:Class rdf:about="&Ontology1308582601209;API">
        <rdfs:label>API</rdfs:label>
        <rdfs:subClassOf rdf:resource="&UvA-SA-ontology;Architecture"/>
    </owl:Class>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Behaviour -->

    <owl:Class rdf:about="&Ontology1308582601209;Behaviour">
        <rdfs:label>Behaviour</rdfs:label>
        <rdfs:subClassOf rdf:resource="&UvA-SA-ontology;Architecture"/>
    </owl:Class>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Concern -->

    <owl:Class rdf:about="&Ontology1308582601209;Concern">
        <rdfs:label>Concern</rdfs:label>
        <rdfs:subClassOf rdf:resource="&UvA-SA-ontology;Requirement"/>
        <rdfs:comment>A concern is a requirement that is introduced by a stakeholder. (adopted in the architecture description context)</rdfs:comment>
    </owl:Class>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Design_issue -->

    <owl:Class rdf:about="&Ontology1308582601209;Design_issue">
        <rdfs:label>Design issue</rdfs:label>
        <rdfs:subClassOf rdf:resource="&owl;Thing"/>
        <rdfs:comment>A design issue is an issue or &#39;problem&#39; that should be solved in order for the system to meet its goals, requirements or to achieve core functionality.
A decision is made regarding the design issue (or it is resolved in later phases) based on various options and rationale on how to address the issue.</rdfs:comment>
    </owl:Class>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Pattern -->

    <owl:Class rdf:about="&Ontology1308582601209;Pattern">
        <rdfs:label>Pattern</rdfs:label>
        <rdfs:subClassOf rdf:resource="&UvA-SA-ontology;Architecture"/>
    </owl:Class>
    


    <!-- http://www.w3.org/2002/07/owl#Thing -->

    <owl:Class rdf:about="&owl;Thing">
        <rdfs:label>All Knowledge</rdfs:label>
    </owl:Class>
    


    <!-- 
    ///////////////////////////////////////////////////////////////////////////////////////
    //
    // Individuals
    //
    ///////////////////////////////////////////////////////////////////////////////////////
     -->

    


    <!-- http://www.archimind.org/archimind/UvA-SA-ontology.owl#Business_Logic_Layer -->

    <owl:NamedIndividual rdf:about="&UvA-SA-ontology;Business_Logic_Layer">
        <rdf:type rdf:resource="&UvA-SA-ontology;Subsystem"/>
        <rdfs:label>Business Logic Layer</rdfs:label>
        <UvA-SA-ontology:name>Business Logic Layer</UvA-SA-ontology:name>
        <UvA-SA-ontology:description>The business logic layer contains the transformation of the initially gathered data to a format that is more easily accessible and analysable, which is accomplished by a set of business rules as defined by users

This is the core of the application; after all data has been abstracted to a certain type of data (version control system data, bug tracking issue data, etc.) the data needs to be coupled and conclusions must be drawn from it.

Business logic layer is synonym for &#39;SNA Layer&#39;</UvA-SA-ontology:description>
        <UvA-SA-ontology:is_modeled_in rdf:resource="&UvA-SA-ontology;component_model"/>
        <UvA-SA-ontology:presented_in rdf:resource="&UvA-SA-ontology;logical_and_implementation_view"/>
        <UvA-SA-ontology:hosted_on rdf:resource="&Ontology1308582601209;Application_server"/>
        <UvA-SA-ontology:compromises_of rdf:resource="&Ontology1308582601209;Business_rules_engine"/>
        <UvA-SA-ontology:compromises_of rdf:resource="&Ontology1308582601209;Configuration_Module"/>
        <UvA-SA-ontology:is_modeled_in rdf:resource="&Ontology1308582601209;Context_diagram"/>
        <UvA-SA-ontology:is_modeled_in rdf:resource="&Ontology1308582601209;Deployment_diagram_-_Primary_presentation"/>
        <UvA-SA-ontology:presented_in rdf:resource="&Ontology1308582601209;Deployment_view"/>
        <UvA-SA-ontology:satisfies rdf:resource="&Ontology1308582601209;Performance"/>
        <UvA-SA-ontology:compromises_of rdf:resource="&Ontology1308582601209;Transformer_(business)"/>
        <UvA-SA-ontology:communicates_with rdf:resource="&Ontology1308582601209;data_access_layer_(relational)"/>
        <UvA-SA-ontology:compromises_of rdf:resource="&Ontology1308582601209;extractor_(business)"/>
    </owl:NamedIndividual>
    


    <!-- http://www.archimind.org/archimind/UvA-SA-ontology.owl#Representation_Layer -->

    <owl:NamedIndividual rdf:about="&UvA-SA-ontology;Representation_Layer">
        <rdf:type rdf:resource="&UvA-SA-ontology;Subsystem"/>
        <rdfs:label>Representation Layer</rdfs:label>
        <UvA-SA-ontology:name>Representation Layer</UvA-SA-ontology:name>
        <UvA-SA-ontology:description>The representation layer contains the way of representing the results of the analysis to the users.

The representation layer is an API  that accesses the graph database . This API contains methods for accessing data based on the business rules set in the business rules engine </UvA-SA-ontology:description>
        <UvA-SA-ontology:is_modeled_in rdf:resource="&UvA-SA-ontology;component_model"/>
        <UvA-SA-ontology:presented_in rdf:resource="&UvA-SA-ontology;logical_and_implementation_view"/>
        <UvA-SA-ontology:hosted_on rdf:resource="&Ontology1308582601209;Application_server"/>
        <UvA-SA-ontology:is_modeled_in rdf:resource="&Ontology1308582601209;Context_diagram"/>
        <UvA-SA-ontology:is_modeled_in rdf:resource="&Ontology1308582601209;Deployment_diagram_-_Primary_presentation"/>
        <UvA-SA-ontology:presented_in rdf:resource="&Ontology1308582601209;Deployment_view"/>
        <UvA-SA-ontology:compromises_of rdf:resource="&Ontology1308582601209;Query_consolidator"/>
        <UvA-SA-ontology:compromises_of rdf:resource="&Ontology1308582601209;Various_client_components"/>
        <UvA-SA-ontology:compromises_of rdf:resource="&Ontology1308582601209;representation_API_"/>
        <realizes rdf:resource="&Ontology1308582601209;representation_API_"/>
    </owl:NamedIndividual>
    


    <!-- http://www.archimind.org/archimind/UvA-SA-ontology.owl#component_model -->

    <owl:NamedIndividual rdf:about="&UvA-SA-ontology;component_model">
        <rdf:type rdf:resource="&UvA-SA-ontology;Diagram"/>
        <rdfs:label>Component model</rdfs:label>
        <UvA-SA-ontology:name>component model</UvA-SA-ontology:name>
        <UvA-SA-ontology:name>A component model is used to show which components should be present in the system in order to meet functional requirements that determine the quality of the system</UvA-SA-ontology:name>
        <UvA-SA-ontology:models rdf:resource="&UvA-SA-ontology;Business_Logic_Layer"/>
        <UvA-SA-ontology:models rdf:resource="&UvA-SA-ontology;Representation_Layer"/>
        <UvA-SA-ontology:models rdf:resource="&UvA-SA-ontology;data_layer"/>
        <UvA-SA-ontology:presented_in rdf:resource="&UvA-SA-ontology;logical_and_implementation_view"/>
        <UvA-SA-ontology:models rdf:resource="&Ontology1308582601209;Analysis_database"/>
        <UvA-SA-ontology:models rdf:resource="&Ontology1308582601209;Business_rules_engine"/>
        <UvA-SA-ontology:models rdf:resource="&Ontology1308582601209;Configuration_Module"/>
        <UvA-SA-ontology:models rdf:resource="&Ontology1308582601209;Extractor"/>
        <UvA-SA-ontology:models rdf:resource="&Ontology1308582601209;Query_consolidator"/>
        <UvA-SA-ontology:models rdf:resource="&Ontology1308582601209;Transformer"/>
        <UvA-SA-ontology:models rdf:resource="&Ontology1308582601209;Transformer_(business)"/>
        <UvA-SA-ontology:models rdf:resource="&Ontology1308582601209;Various_client_components"/>
        <UvA-SA-ontology:models rdf:resource="&Ontology1308582601209;data_access_layer_(analysis)"/>
        <UvA-SA-ontology:models rdf:resource="&Ontology1308582601209;data_access_layer_(relational)"/>
        <UvA-SA-ontology:models rdf:resource="&Ontology1308582601209;extractor_(business)"/>
        <UvA-SA-ontology:models rdf:resource="&Ontology1308582601209;relational_database"/>
        <UvA-SA-ontology:models rdf:resource="&Ontology1308582601209;representation_API_"/>
    </owl:NamedIndividual>
    


    <!-- http://www.archimind.org/archimind/UvA-SA-ontology.owl#data_layer -->

    <owl:NamedIndividual rdf:about="&UvA-SA-ontology;data_layer">
        <rdf:type rdf:resource="&UvA-SA-ontology;Subsystem"/>
        <rdfs:label>Data Layer</rdfs:label>
        <UvA-SA-ontology:name>Data Layer</UvA-SA-ontology:name>
        <UvA-SA-ontology:description>The data layer is the layer that accommodates the gathering of data from the various project assisting tools used by Previous.

Within the data layer , the extractor component communicates with the various data stores of the tools  used by previous . 

This layer is responsible for retrieving, abstracting and aggregating data from multiple sources in preparation for the actual analysis of the data

A synonym for data layer is - &quot;Data collector layer&quot;</UvA-SA-ontology:description>
        <UvA-SA-ontology:is_modeled_in rdf:resource="&UvA-SA-ontology;component_model"/>
        <UvA-SA-ontology:presented_in rdf:resource="&UvA-SA-ontology;logical_and_implementation_view"/>
        <UvA-SA-ontology:hosted_on rdf:resource="&Ontology1308582601209;Application_server"/>
        <UvA-SA-ontology:is_modeled_in rdf:resource="&Ontology1308582601209;Context_diagram"/>
        <UvA-SA-ontology:is_modeled_in rdf:resource="&Ontology1308582601209;Deployment_diagram_-_Primary_presentation"/>
        <UvA-SA-ontology:presented_in rdf:resource="&Ontology1308582601209;Deployment_view"/>
        <UvA-SA-ontology:compromises_of rdf:resource="&Ontology1308582601209;Extractor"/>
        <UvA-SA-ontology:compromises_of rdf:resource="&Ontology1308582601209;Transformer"/>
        <UvA-SA-ontology:communicates_with rdf:resource="&Ontology1308582601209;data_access_layer_(relational)"/>
    </owl:NamedIndividual>
    


    <!-- http://www.archimind.org/archimind/UvA-SA-ontology.owl#logical_and_implementation_view -->

    <owl:NamedIndividual rdf:about="&UvA-SA-ontology;logical_and_implementation_view">
        <rdf:type rdf:resource="&UvA-SA-ontology;View"/>
        <rdfs:label>logical and implementation view</rdfs:label>
        <UvA-SA-ontology:description>The logical and implementation view explains our thoughts on the functionality that should be made available in this system, using a graphical representation of the view, along with explanations in various sections.</UvA-SA-ontology:description>
        <UvA-SA-ontology:name>logical and implementation view</UvA-SA-ontology:name>
        <UvA-SA-ontology:presents rdf:resource="&UvA-SA-ontology;Business_Logic_Layer"/>
        <UvA-SA-ontology:presents rdf:resource="&UvA-SA-ontology;Representation_Layer"/>
        <UvA-SA-ontology:presents rdf:resource="&UvA-SA-ontology;data_layer"/>
        <UvA-SA-ontology:presents rdf:resource="&Ontology1308582601209;data_access_layer_(analysis)"/>
        <UvA-SA-ontology:presents rdf:resource="&Ontology1308582601209;data_access_layer_(relational)"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#11_logical_and_implementation_view_-_background_-_rationale_-_coupling_persising_presenting_data -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;11_logical_and_implementation_view_-_background_-_rationale_-_coupling_persising_presenting_data">
        <rdf:type rdf:resource="&UvA-SA-ontology;WikiPage"/>
        <rdfs:label>11 logical and implementation view - background - rationale - coupling_persising_presenting data</rdfs:label>
        <ontowiki_WikiPage:content>&lt;p&gt;
	&lt;strong&gt;Coupling and persisting/presenting the data&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	After the data has been abstracted and gathered, it still needs to be processed. It is useful to have already assigned some properties to users (such as: &amp;ldquo;is expert on&amp;rdquo;) and to have made connections between users.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	Making connections between users is relatively simple, for example in an email the sender and recipient can be connected, but deciding when a user is an expert for example is a lot different. There is no obvious way to decide when a user is an expert, there is some sort of rule required to decide when this is the case.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	Thus, to achieve this goal some sort of rule handling is required. In this chapter we will discuss two methods to do this, one in which the rules are hard-coded into the business logic layer and one which uses a business rules engine.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;Hard-coded rules&lt;br /&gt;
	&lt;br /&gt;
	&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
	The simplest way to achieve this goal is by hard-coding the rules in some service in the business logic layer. When data is being processed, the service is called to decide what properties to give the user. Advantages and disadvantages are listed in the appendix under section:Hard Coded rules&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;Business rules engine&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	Another possible solution is the implementation of a business rules engine, which according to the Wikipedia page about it (&lt;a href=&quot;http://en.wikipedia.org/wiki/Business_rules_engine&quot;&gt;&lt;em&gt;http://en.wikipedia.org/wiki/Business_rules_engine&lt;/em&gt;&lt;/a&gt;&lt;em&gt;)&lt;/em&gt; &amp;ldquo;executes one or more business rules in a runtime production environment&amp;rdquo;. Advantages and disadvantages are listed in the appendix under section:Business rules engine&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;Data storage&lt;br /&gt;
	&lt;br /&gt;
	&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
	After coupling the data and drawing some conclusions from it, the data needs to be stored in some sort of database.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	After storing this data in the database, we will be able to query it in order to ask questions such as: &amp;ldquo;Which developers communicate with each other?&amp;rdquo; or &amp;ldquo;Who operates as a bridge for communication?&amp;rdquo; or &amp;ldquo;Is anyone completely isolated?&amp;rdquo;. Answering these types of questions is the main goal of the application. In order to conform to the one of the key quality attributes the stakeholders requested, performance, these types of queries need to be able to answer such questions as rapidly as possible.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	A database type that is by far the most popular one around is the relational database. These types of databases have been around since the 1970s and are proven technology with a large community.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	Another option is graph databases, which are relatively new in the field though the graph theory that preceded it is quite a bit older. These are more oriented towards objects and their inter-relationships. This is interesting as getting insight in relations between entities is basically what this application is required to do.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	Therefore we researched these two possibilities for storing the data processed in the Business Layer. First we&amp;rsquo;ll briefly explain how both the relational database and the graph database work. Next, we&amp;rsquo;ll discuss its advantages and disadvantages and finally conclude by saying how well fit either approach is for this problem and which solution we recommend.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
</ontowiki_WikiPage:content>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#12_logical_and_implementation_view_-_background_-_rationale_-_relational_database_system -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;12_logical_and_implementation_view_-_background_-_rationale_-_relational_database_system">
        <rdf:type rdf:resource="&UvA-SA-ontology;WikiPage"/>
        <rdfs:label>12 logical and implementation view - background - rationale - relational database system</rdfs:label>
        <ontowiki_WikiPage:content>&lt;p&gt;
	&lt;strong&gt;Relational database system&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;Explanation&lt;br /&gt;
	&lt;br /&gt;
	&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
	In a relational database system, data is stored in tables that have relationships to each other using primary and foreign keys. The combining of these tables (terminology: joining of tables) to retrieve certain data can often be an expensive task. The relational database system would have to store multiple tables of data in order to prevent duplication. A (part of the database) could look like this for example:&lt;br /&gt;
	&lt;br /&gt;
	Table: communication&lt;/p&gt;
&lt;table border=&quot;0&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; style=&quot;width:624px;&quot; width=&quot;624&quot;&gt;
	&lt;tbody&gt;
		&lt;tr&gt;
			&lt;td&gt;
				&lt;p&gt;
					&lt;strong&gt;communication_id&lt;/strong&gt;&lt;/p&gt;
			&lt;/td&gt;
			&lt;td&gt;
				&lt;p&gt;
					&lt;strong&gt;first_person_id&lt;/strong&gt;&lt;/p&gt;
			&lt;/td&gt;
			&lt;td&gt;
				&lt;p&gt;
					&lt;strong&gt;second_person_id&lt;/strong&gt;&lt;/p&gt;
			&lt;/td&gt;
			&lt;td&gt;
				&lt;p&gt;
					&lt;strong&gt;project_id&lt;/strong&gt;&lt;/p&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;
				&lt;p&gt;
					1&lt;/p&gt;
			&lt;/td&gt;
			&lt;td&gt;
				&lt;p&gt;
					172&lt;/p&gt;
			&lt;/td&gt;
			&lt;td&gt;
				&lt;p&gt;
					383&lt;/p&gt;
			&lt;/td&gt;
			&lt;td&gt;
				&lt;p&gt;
					9292&lt;/p&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;
				&lt;p&gt;
					2&lt;/p&gt;
			&lt;/td&gt;
			&lt;td&gt;
				&lt;p&gt;
					383&lt;/p&gt;
			&lt;/td&gt;
			&lt;td&gt;
				&lt;p&gt;
					482&lt;/p&gt;
			&lt;/td&gt;
			&lt;td&gt;
				&lt;p&gt;
					3038&lt;/p&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;
				&lt;p&gt;
					3&lt;/p&gt;
			&lt;/td&gt;
			&lt;td&gt;
				&lt;p&gt;
					383&lt;/p&gt;
			&lt;/td&gt;
			&lt;td&gt;
				&lt;p&gt;
					593&lt;/p&gt;
			&lt;/td&gt;
			&lt;td&gt;
				&lt;p&gt;
					492&lt;/p&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;
	&lt;br /&gt;
	Table: persons&lt;/p&gt;
&lt;table border=&quot;0&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; style=&quot;width:624px;&quot; width=&quot;624&quot;&gt;
	&lt;tbody&gt;
		&lt;tr&gt;
			&lt;td&gt;
				&lt;p&gt;
					&lt;strong&gt;person_id&lt;/strong&gt;&lt;/p&gt;
			&lt;/td&gt;
			&lt;td&gt;
				&lt;p&gt;
					&lt;strong&gt;full_name&lt;/strong&gt;&lt;/p&gt;
			&lt;/td&gt;
			&lt;td&gt;
				&lt;p&gt;
					&lt;strong&gt;profession&lt;/strong&gt;&lt;/p&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;
				&lt;p&gt;
					172&lt;/p&gt;
			&lt;/td&gt;
			&lt;td&gt;
				&lt;p&gt;
					David Smith&lt;/p&gt;
			&lt;/td&gt;
			&lt;td&gt;
				&lt;p&gt;
					Junior Programmer&lt;/p&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;
				&lt;p&gt;
					383&lt;/p&gt;
			&lt;/td&gt;
			&lt;td&gt;
				&lt;p&gt;
					Jeremy Bakersfield&lt;/p&gt;
			&lt;/td&gt;
			&lt;td&gt;
				&lt;p&gt;
					Senior Programmer&lt;/p&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;
				&lt;p&gt;
					482&lt;/p&gt;
			&lt;/td&gt;
			&lt;td&gt;
				&lt;p&gt;
					Lucas Morgan&lt;/p&gt;
			&lt;/td&gt;
			&lt;td&gt;
				&lt;p&gt;
					Medior Programmer&lt;/p&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;
				&lt;p&gt;
					593&lt;/p&gt;
			&lt;/td&gt;
			&lt;td&gt;
				&lt;p&gt;
					Hank Copperfield&lt;/p&gt;
			&lt;/td&gt;
			&lt;td&gt;
				&lt;p&gt;
					Intern&lt;/p&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	Table: subjects&lt;/p&gt;
&lt;table border=&quot;0&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot;&gt;
	&lt;tbody&gt;
		&lt;tr&gt;
			&lt;td style=&quot;height:21px;&quot;&gt;
				&lt;p&gt;
					&lt;strong&gt;project_id&lt;/strong&gt;&lt;/p&gt;
			&lt;/td&gt;
			&lt;td style=&quot;height:21px;&quot;&gt;
				&lt;p&gt;
					&lt;strong&gt;project_title&lt;/strong&gt;&lt;/p&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;height:5px;&quot;&gt;
				&lt;p&gt;
					9292&lt;/p&gt;
			&lt;/td&gt;
			&lt;td style=&quot;height:5px;&quot;&gt;
				&lt;p&gt;
					Public Transport Information System&lt;/p&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;height:1px;&quot;&gt;
				&lt;p&gt;
					3038&lt;/p&gt;
			&lt;/td&gt;
			&lt;td style=&quot;height:1px;&quot;&gt;
				&lt;p&gt;
					Bank Transaction system&lt;/p&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;
				&lt;p&gt;
					492&lt;/p&gt;
			&lt;/td&gt;
			&lt;td&gt;
				&lt;p&gt;
					NFC research&lt;/p&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;
	&lt;br /&gt;
	From this data, it can be concluded that Jeremy Bakersfield acts as a central bridge of communication for 2 other developers and about three projects about an information system for public transport, a bank transaction system and research about NFC. In order to reach this conclusion three tables need to be joined together, which can cost more and more performance as the data set grows larger. Also, every occurrence of communication gets its own database record. This problem set can easily grow quite large.A list of disadvantages and advantages can be found in the appendix under section: Relational Database system&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;Graph database system&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;Explanation&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	Though relational databases have broadly been used for decades now, they do have their limitations. As stated in the previous paragraphs, joining tables together costs a lot of processing power. In graph databases there are entities and relationships (nodes and edges). These relationships play an important role in the database system.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;&amp;lt;picture&amp;gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
	These graph databases provide a huge performance advantage over relational databases when querying for information that would otherwise require one or multiple joins.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	In a benchmark performed by researchers from the University of Mississippi [1], the performance of a popular relational database (MySQL) is compared to the performance of a popular graph database (Neo4j).&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	They say that &amp;ldquo;Graphs were created to contain approximately 1000, 5000, 10000, and 100000 nodes to aid in assessing scalability. The type of payload data stored in each node also varied. The payloads consisted of random integers, random 8KB strings, and random 32KB strings. Thus, twelve MySQL and twelve Neo4j databases were constructed from the random graphs.&amp;rdquo;&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	They also state that the size of the graph database is usually about 1.5 to 2 times larger in megabytes. This is certainly something to consider, but it doesn&amp;rsquo;t outweigh the gain in performance since data storage is quite cheap nowadays.&lt;/p&gt;
&lt;p&gt;
	The queries they&amp;rsquo;ve used to test the database are divided into two categories: structural and data queries. They define three structural queries:&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	-&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Find all orphan nodes. That is, find all nodes in the graph that are singletons, with no incoming edges and no outgoing edges&lt;/p&gt;
&lt;br clear=&quot;all&quot; /&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	-&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	-&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Traverse the graph to a depth of 4 and count the number of nodes reachable&lt;/p&gt;
&lt;p&gt;
	-&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Traverse the graph to a depth of 128 and count the number of nodes reachable&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	As well as three data queries:&lt;/p&gt;
&lt;p&gt;
	-&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Count the number of nodes whose payload data is equal to some value&lt;/p&gt;
&lt;p&gt;
	-&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Count the number of nodes whose payload data is less than some value&lt;/p&gt;
&lt;p&gt;
	-&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Count the number of nodes whose payload data contains some search string (length ranges from 4 to 8)&lt;br /&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	They conclude that in the first type of queries, the Neo4j database performed a lot better than the MySQL database. Sometimes this was even an order of magnitude faster. However, the opposite is true for the latter three queries. A list of disadvantages and advantages can be found in the appendix under section: &amp;ldquo;Graph Database system&amp;rdquo;.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;Conclusion&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	After explaining the two database choices as well as their advantages and disadvantages for this specific situation, a choice needs to be made. In this chapter we outweigh the pros and cons and come to an advice for the stakeholders which type of database system to implement.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	One of the desired key qualities for the application as requested by the stakeholders is performance. They do not wish to wait for a long time in order for an analysis to finish. In order to deal with this problem, we decided to store several analysed data in a database rather than retrieve it every time the user makes a request.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	This alone is however not assurance enough that the system will perform in a fast manner, since a lot of data still needs to be coupled in order to view communication between developers, trace isolated developers, etc. Due to the performance bottleneck that a relational database has the graph database seems like a fit solution for these types of queries.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	As can be read in the explanation section of the graph database, it can perform up to an order of a magnitude faster than a relational database with these types of queries. Queries which take field values and do something with this (i.e. sum them) are performed faster in a relational database, but these are a lot less interesting as the first type will be queried much more.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	The question is then whether the disadvantages of using a graph database can be overcome, the fact that there&amp;rsquo;s less expertise available and that it needs up to twice as much space to store its data. The latter is certainly no showstopper as disk storage has become cheaper and cheaper in the past few years.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	The fact that the database type hasn&amp;rsquo;t been around for too much time certainly puts it behind relational databases regarding its maturity as well as availability for high quality tools. However, the concept is gaining attention in the past few years and big companies such as Google, Facebook and LinkedIn now use this technology so this will most likely improve even further over time.&lt;/p&gt;
&lt;p&gt;
	We conclude that the graph database is therefore the best fit for this problem, provided that the developers that will ultimately create this application study the ins and outs of it thoroughly. The performance gain and the fact that large companies to achieve similar goals use this sort of database system provide us enough confidence to recommend this solution.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
</ontowiki_WikiPage:content>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#13_logical_and_implementation_view_-_background_-_rationale_-_representation_layer -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;13_logical_and_implementation_view_-_background_-_rationale_-_representation_layer">
        <rdf:type rdf:resource="&UvA-SA-ontology;WikiPage"/>
        <rdfs:label>13 logical and implementation view - background - rationale - representation layer</rdfs:label>
        <ontowiki_WikiPage:content>&lt;p&gt;
	&lt;strong&gt;Representation layer&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	After the data has been processed and persisted in a database, there must be a way for users to retrieve the data from the system. The stakeholders have said that they would like an API so they could hook up external applications to it easily. With this in mind, we shaped the representation layer as follows:&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	The API is the point the web application, reporting engine, Eclipse plugin or anything can communicate with in order to retrieve data from the database. This doesn&amp;rsquo;t contain any logic itself, but just handles the requests and delegates the work to the underlying Query Consolidator service that in turn communicates with the database via a data access layer.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	Since the API was a requirement and the data access layer is a standard way of separating the application logic from the database access the only thing that really needed to be decided was whether to make the Query Consolidator separate from the API or not. This too, is standard in application development. Controllers should not contain any logic; this is a task for the services.&lt;/p&gt;
</ontowiki_WikiPage:content>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#14_logical_and_implementation_view_-_background_-_rationale_-_analysis_results_and_assumptions -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;14_logical_and_implementation_view_-_background_-_rationale_-_analysis_results_and_assumptions">
        <rdf:type rdf:resource="&UvA-SA-ontology;WikiPage"/>
        <rdfs:label>14 logical and implementation view - background - rationale - analysis results and assumptions</rdfs:label>
        <ontowiki_WikiPage:content>&lt;h3&gt;
	1.5.2 Analysis of results&lt;/h3&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	The most important quality feature desired by the stakeholders is extensibility, they want to keep their options open to easily implement support for new systems in the application.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	As described earlier, the application has been designed to provide flexibility when adding a new system to retrieve data from. As can be read in the next chapter, the assumption is that tools will more frequently change than tool types. Here we will describe what needs to be done when adding support for a new tool to the application.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	First of all, a new data gatherer needs to be written which knows how to retrieve the necessary data from the system. This gatherer must gather the information and abstract it to the data type that has been chosen for the aggregate system type data. If the system type the new system belongs to is already present in the application, this is all that needs to be done.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	When adding an entirely new system type, some more work is in order. Apart from the creation of a new gatherer, the logic that deals with the combined data and draws conclusions to it must be adapted. This means that an addition to the business logic layer is also necessary. Probably some rules need to be added to the business rules engine. Also, the extractor and transformer need to be adapted in order to deal with the processing of the new data types.&lt;/p&gt;
&lt;h3&gt;
	1.5.3 Assumptions&lt;/h3&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	Some assumptions that we have made when working out this design is that there is a way to extract data from each critical system. This could be by using an API or reading data from a file processed by it, but there must be SOME way. An application that outputs no data to an accessible source is not useable for this type of problem.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	Another assumption is the fact that though the stakeholders have stated that they&amp;rsquo;re always looking for new tools to do a better job, the TYPE of tools probably doesn&amp;rsquo;t change as often. For example, SVN used to be the industry standard for version control but now the industry is moving more towards decentralized versioning control systems. The implementation changes, but the general idea is still the same: it holds a record of code adaptations from one or multiple developers. This assumption has been tested with the stakeholders, and they agree.&lt;/p&gt;
</ontowiki_WikiPage:content>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#15_logical_and_implementation_view_-_background_-_rationale_-_glossary_of_terms -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;15_logical_and_implementation_view_-_background_-_rationale_-_glossary_of_terms">
        <rdf:type rdf:resource="&UvA-SA-ontology;WikiPage"/>
        <rdfs:label>15 logical and implementation view - background - rationale - glossary of terms</rdfs:label>
        <ontowiki_WikiPage:content>&lt;h2&gt;
	1.6 Glossary of terms&lt;/h2&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;SNA System:&lt;/strong&gt;SNA stands for Social Network Analysis. An SNA system is a software system that allows one to analyse the workings of a social network in greater detail.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;API: &lt;/strong&gt;API stands for Application Programming Interface. This is a special service or library that can be integrated within a user interface or plug-in, which can access (in our case) the data from the graph database.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;Graph database:&lt;/strong&gt;Unlike a relational database that stores objects and defines relations through the use of keys, a Graph database stores the actual relationship as well. This database is therefore especially suited to answer queries that do not only involve the object, but also its relationships.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;Sequence diagram: &lt;/strong&gt;In standard UML, a sequence diagram is used to represent the method calls between certain system components. In this case, we used the sequence diagram to show at a more abstract level what the flow of the system should be.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;UML: &lt;/strong&gt;UML stands for Unified Modelling Language, a language used as a standard for creating diagrams and models that represent software systems.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;Versioning tools:&lt;/strong&gt;Versioning tools are tools used by software developers to keep track of item versions. Each time a developer wishes to update a line of code in some file and commits this change through the versioning tool, the tool will assign a higher version to the modified item and will keep track of any changes made to the item.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;Project management tools: &lt;/strong&gt;Project management tools are used to keep track of the current status of a project team. It lists TO-DO items, features a planning mechanism and some form of reporting for superiors.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;Bug tracking tools:&lt;/strong&gt;A bug tracking tool is used to keep track of bugs found in a system or code file. Using a bug tracker, a development team can keep track of the files that cause the most problems and which bugs are repeating in occurrence. Therefore, it will become easier for the team to fix these bugs in the future.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;Bug:&lt;/strong&gt;A complication within a software system that causes unwanted or unexpected system behaviour.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;Communication tools: &lt;/strong&gt;Tools used to facilitate documentation. For example: Outlook (for e-mail), Lync or IRC (For instant messaging).&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;Active Directory: &lt;/strong&gt;Active Directory, or AD for short, handles Windows user authentication when implemented on a server (which is the case for Previous). When a user logs into a computer using an account from the AD, that user can instantly access any tools that implement AD as their log-in module, given they have the correct rights to access these tools.&lt;/p&gt;
</ontowiki_WikiPage:content>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#16_Deployment_view_-_primary_presentation_and_element_catalog -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;16_Deployment_view_-_primary_presentation_and_element_catalog">
        <rdf:type rdf:resource="&UvA-SA-ontology;WikiPage"/>
        <rdfs:label>16 Deployment view - primary presentation and element catalog</rdfs:label>
        <ontowiki_WikiPage:content>&lt;h1&gt;
	2. Deployment view&lt;/h1&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;
	2.1 Primary presentation of the view&lt;/h2&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;
	2.2 Element Catalog&lt;/h2&gt;
&lt;p&gt;
	&lt;br /&gt;
	In this section we will explain the terminology used in this view. It can be used as a legend to this view and it explains what each component means. The view is represented using a UML 2.0 deployment diagram.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	The view shows how the system is distributed on two physical nodes: an application server and database server. The application server contains all the layers of the SNA system (as can be seen in the logical &amp;amp; implementation view) and includes a web server (API) where clients connect to.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	The application server connects to the database server for storage and retrieval of intermediate results of the tool extraction and analysis. There are two different databases: one to store the results of the data extractor which holds a subset of the data from the different tools used by the stakeholder, and a second database to store the results of the analyses (performed by the business logic) on the tool data.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
</ontowiki_WikiPage:content>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#17_Deployment_view_-_context_diagram -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;17_Deployment_view_-_context_diagram">
        <rdf:type rdf:resource="&UvA-SA-ontology;WikiPage"/>
        <rdfs:label>17 Deployment view - context diagram</rdfs:label>
        <ontowiki_WikiPage:content>&lt;h2&gt;
	2.3 Context diagram&lt;/h2&gt;
&lt;p&gt;
	&lt;br /&gt;
	The SNA system is deployed inside the existing network infrastructure of the stakeholder. The diagram below shows how the SNA system integrates into this infrastructure.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	The diagram is a replication of the existing infrastructure as supplied by the stakeholder. It consists of two separated diagrams: one for the headquarter site in Amsterdam and one for all non-headquarter sites. The headquarter and all other sites are connected to each other through a router and secure VPN connection.&amp;nbsp; This way all sites can access the existing production tools which are represented as &amp;lsquo;existing (tool) servers&amp;rsquo; in the view. These contain the Exchange (mail), Jira / Confluence (issue tracking / wiki) and HG/LDAP (revision control / directory services) server.&lt;/p&gt;
&lt;p&gt;
	All workstations can connect to these servers as they are all on the same (logical) network.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	The SNA system is distributed on two servers which are connected on the same network. Therefore all workstations have access to the SNA system too. Workstations only connect directly to the application server, not to the database server.&lt;/p&gt;
</ontowiki_WikiPage:content>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#18_Deployment_view_-_architecture_background_-_rationale_and_assumptions -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;18_Deployment_view_-_architecture_background_-_rationale_and_assumptions">
        <rdf:type rdf:resource="&UvA-SA-ontology;WikiPage"/>
        <rdfs:label>18 Deployment view - architecture background - rationale and assumptions</rdfs:label>
        <ontowiki_WikiPage:content>&lt;h2&gt;
	2.5 Architecture background&lt;/h2&gt;
&lt;p&gt;
	&lt;br /&gt;
	This section will describe the rationale and assumptions of the proposed architecture.&lt;/p&gt;
&lt;h3&gt;
	2.5.1 Design rationale&lt;/h3&gt;
&lt;p&gt;
	The stakeholders main concerns for deployment where a minimum amount of configuration, no changes to the existing infrastructure, conformance to existing security regulations and a minimal additional load on existing servers. In essence the SNA system should work as a non-critical standalone system integrated within the corporate infrastructure and security guidelines.&lt;/p&gt;
&lt;p&gt;
	We therefore designed the SNA system on two separate physical servers within the current network infrastructure. All configuration is applied to these servers directly (eg. which tools to extract data from) and thus requires no additional maintenance of the existing servers. The SNA system behaves like a workstation client when connecting to existing tool servers and therefore stresses a minimal additional load on these servers.&lt;/p&gt;
&lt;p&gt;
	The database server is separated from the application server to increase security. Clients only connect to the application server, using the API services, so the SNA system controls the authentication and authorization of who can do what.&lt;/p&gt;
&lt;h3&gt;
	2.5.3 Assumptions&lt;/h3&gt;
&lt;p&gt;
	The SNA system extracts data from existing tool servers (eg. Jira, mail, etc.); specifically, it only extracts &lt;em&gt;a subset of data&lt;/em&gt; from these servers. So it is assumed that the workload of the SNA system is lower than existing servers (which processes the full datasets). Therefore the SNA system is deployed on a single system of two servers and there is no need for a distributed cluster of servers.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
</ontowiki_WikiPage:content>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#19_Appendix_-_Databases_or_Flat_file_Data_stores -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;19_Appendix_-_Databases_or_Flat_file_Data_stores">
        <rdf:type rdf:resource="&UvA-SA-ontology;WikiPage"/>
        <rdfs:label>19 Appendix - Databases or Flat file Data stores</rdfs:label>
        <ontowiki_WikiPage:content>&lt;h1&gt;
	Appendix A&lt;/h1&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;
	Databases or Flat file Data stores:&lt;/h2&gt;
&lt;p&gt;
	The data collector needs to temporary stores his extracted data, to provide them to the SNA component. The data collector can accomplish that in two ways, store them in a database or in separate flat file formats, like xml, CSV or an own simple data structure.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	Advantages between the types of data stores systems:&lt;/p&gt;
&lt;table border=&quot;1&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot;&gt;
	&lt;tbody&gt;
		&lt;tr&gt;
			&lt;td colspan=&quot;2&quot; style=&quot;width:281px;&quot;&gt;
				&lt;p&gt;
					Database&lt;/p&gt;
			&lt;/td&gt;
			&lt;td colspan=&quot;2&quot; style=&quot;width:281px;&quot;&gt;
				&lt;p&gt;
					Flat file&lt;/p&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;width:130px;&quot;&gt;
				&lt;p&gt;
					Advantage&lt;/p&gt;
			&lt;/td&gt;
			&lt;td style=&quot;width:151px;&quot;&gt;
				&lt;p&gt;
					Description&lt;/p&gt;
			&lt;/td&gt;
			&lt;td style=&quot;width:104px;&quot;&gt;
				&lt;p&gt;
					Advantage&lt;/p&gt;
			&lt;/td&gt;
			&lt;td style=&quot;width:177px;&quot;&gt;
				&lt;p&gt;
					Description&lt;/p&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;width:130px;&quot;&gt;
				&lt;p&gt;
					Multi access, read &amp;amp; write&lt;/p&gt;
			&lt;/td&gt;
			&lt;td style=&quot;width:151px;&quot;&gt;
				&lt;p&gt;
					Multithreaded read and write access, managed by the database system.&lt;/p&gt;
			&lt;/td&gt;
			&lt;td style=&quot;width:104px;&quot;&gt;
				&lt;p&gt;
					No extra costs, except space&lt;/p&gt;
			&lt;/td&gt;
			&lt;td style=&quot;width:177px;&quot;&gt;
				&lt;p&gt;
					The flat files could be stored at the server hard disk.&lt;/p&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;width:130px;&quot;&gt;
				&lt;p&gt;
					Transaction save&lt;/p&gt;
			&lt;/td&gt;
			&lt;td style=&quot;width:151px;&quot;&gt;
				&lt;p&gt;
					Data stay consistent through several writes in the same table.&lt;/p&gt;
			&lt;/td&gt;
			&lt;td style=&quot;width:104px;&quot;&gt;
				&lt;p&gt;
					No access lib&amp;rsquo;s&lt;/p&gt;
			&lt;/td&gt;
			&lt;td style=&quot;width:177px;&quot;&gt;
				&lt;p&gt;
					Every common programming language provides native.&lt;/p&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;width:130px;&quot;&gt;
				&lt;p&gt;
					Relation between data&lt;/p&gt;
			&lt;/td&gt;
			&lt;td style=&quot;width:151px;&quot;&gt;
				&lt;p&gt;
					Relations can be queried, for example with the LDAP User ID.&lt;/p&gt;
			&lt;/td&gt;
			&lt;td style=&quot;width:104px;&quot;&gt;
				&lt;p&gt;
					-&lt;/p&gt;
			&lt;/td&gt;
			&lt;td style=&quot;width:177px;&quot;&gt;
				&lt;p&gt;
					-&lt;/p&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;width:130px;&quot;&gt;
				&lt;p&gt;
					Optimized data storing&lt;/p&gt;
			&lt;/td&gt;
			&lt;td style=&quot;width:151px;&quot;&gt;
				&lt;p&gt;
					Optimized data storage in a relational way.&lt;/p&gt;
			&lt;/td&gt;
			&lt;td style=&quot;width:104px;&quot;&gt;
				&lt;p&gt;
					-&lt;/p&gt;
			&lt;/td&gt;
			&lt;td style=&quot;width:177px;&quot;&gt;
				&lt;p&gt;
					-&lt;/p&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	Disadvantages between the types of data stores systems:&lt;/p&gt;
&lt;table border=&quot;1&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot;&gt;
	&lt;tbody&gt;
		&lt;tr&gt;
			&lt;td colspan=&quot;2&quot; style=&quot;width:272px;&quot;&gt;
				&lt;p&gt;
					Database&lt;/p&gt;
			&lt;/td&gt;
			&lt;td colspan=&quot;2&quot; style=&quot;width:296px;&quot;&gt;
				&lt;p&gt;
					Flat file&lt;/p&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;width:130px;&quot;&gt;
				&lt;p&gt;
					Disadvantage&lt;/p&gt;
			&lt;/td&gt;
			&lt;td style=&quot;width:142px;&quot;&gt;
				&lt;p&gt;
					Description&lt;/p&gt;
			&lt;/td&gt;
			&lt;td style=&quot;width:123px;&quot;&gt;
				&lt;p&gt;
					Disadvantage&lt;/p&gt;
			&lt;/td&gt;
			&lt;td style=&quot;width:173px;&quot;&gt;
				&lt;p&gt;
					Description&lt;/p&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;width:130px;&quot;&gt;
				&lt;p&gt;
					Extra costs&lt;/p&gt;
			&lt;/td&gt;
			&lt;td style=&quot;width:142px;&quot;&gt;
				&lt;p&gt;
					In administration and hardware.&lt;/p&gt;
			&lt;/td&gt;
			&lt;td style=&quot;width:123px;&quot;&gt;
				&lt;p&gt;
					Single access, write&lt;/p&gt;
			&lt;/td&gt;
			&lt;td style=&quot;width:173px;&quot;&gt;
				&lt;p&gt;
					Only on thread can read and write. &amp;ndash; in Performance.&lt;/p&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;width:130px;&quot;&gt;
				&lt;p&gt;
					Extra connector lib&amp;rsquo;s needed&lt;/p&gt;
			&lt;/td&gt;
			&lt;td style=&quot;width:142px;&quot;&gt;
				&lt;p&gt;
					The disadvantages here are extra costs for commercial database connection libraries, but this only if commercial databases are used, for open source, it&amp;rsquo;s not a disadvantage.&lt;/p&gt;
			&lt;/td&gt;
			&lt;td style=&quot;width:123px;&quot;&gt;
				&lt;p&gt;
					Bottleneck&lt;/p&gt;
			&lt;/td&gt;
			&lt;td style=&quot;width:173px;&quot;&gt;
				&lt;p&gt;
					The Flat files create a bottleneck in focus on performance, because only one single thread could read and write at a time. For a more performance based read and writing service Flat files not very suited.&lt;/p&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;br clear=&quot;all&quot; /&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;Conclusion:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
	As to see from the table, beside the extra costs compared with a flat file data store structure are only advantages to use an&amp;nbsp; database system for the data collector component to store his transformed data.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;Decision:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
	The decision is based on the conclusion made before. The systems data collector component needs a Database system to store the raw data in a small, simple database table. A Database system brings more flexibility, security (Transaction save), data integrity, performance then a flat file structured data store.&lt;/p&gt;
</ontowiki_WikiPage:content>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#1_-_Title_and_index -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;1_-_Title_and_index">
        <rdf:type rdf:resource="&UvA-SA-ontology;WikiPage"/>
        <rdfs:label>1 title and index</rdfs:label>
        <ontowiki_WikiPage:content>&lt;div&gt;
	&lt;h1 align=&quot;center&quot;&gt;
		Architecture Description&lt;/h1&gt;
&lt;/div&gt;
&lt;h1 align=&quot;center&quot;&gt;
	SNA System for Previous&lt;/h1&gt;
&lt;p&gt;
	&lt;strong&gt;Date:&lt;/strong&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 30-09-2012&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;Group: &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/strong&gt;GR_D2_5&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;Members:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/strong&gt;Jesse van Assen&lt;/p&gt;
&lt;p style=&quot;margin-left:72.0pt;&quot;&gt;
	Sander Benschop&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Sander Leer&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Jelle Notenboom&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Sven Rohde&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;Stakeholders:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/strong&gt;GR_D2_2 (Previous)&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;Table of contents&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	1.Logical &amp;amp; Implementation view......................................................................... 3&lt;/p&gt;
&lt;p&gt;
	1.1 Primary presentation of the view.......................................................................................... 3&lt;/p&gt;
&lt;p&gt;
	1.2 Element Catalog................................................................................................................................. 3&lt;/p&gt;
&lt;p&gt;
	1.2.1 Elements and their properties........................................................................................ 4&lt;/p&gt;
&lt;p&gt;
	1.2.2 Relations and their properties........................................................................................ 6&lt;/p&gt;
&lt;p&gt;
	1.2.3 Element interfaces.................................................................................................................. 7&lt;/p&gt;
&lt;p&gt;
	1.2.4 Element behaviour................................................................................................................. 7&lt;/p&gt;
&lt;p&gt;
	1.3 Context diagram............................................................................................................................. 10&lt;/p&gt;
&lt;p&gt;
	1.4 Variability guide.............................................................................................................................. 10&lt;/p&gt;
&lt;p&gt;
	1.5 Architecture background.......................................................................................................... 10&lt;/p&gt;
&lt;p&gt;
	1.5.1 Design rationale.................................................................................................................... 10&lt;/p&gt;
&lt;p&gt;
	1.5.2 Analysis of results................................................................................................................ 20&lt;/p&gt;
&lt;p&gt;
	1.5.3 Assumptions............................................................................................................................ 21&lt;/p&gt;
&lt;p&gt;
	1.6 Glossary of terms........................................................................................................................... 21&lt;/p&gt;
&lt;p&gt;
	2. Deployment view............................................................................................... 23&lt;/p&gt;
&lt;p&gt;
	2.1 Primary presentation of the view....................................................................................... 23&lt;/p&gt;
&lt;p&gt;
	2.2 Element Catalog.............................................................................................................................. 23&lt;/p&gt;
&lt;p&gt;
	2.3 Context diagram............................................................................................................................. 24&lt;/p&gt;
&lt;p&gt;
	2.5 Architecture background.......................................................................................................... 25&lt;/p&gt;
&lt;p&gt;
	2.5.1 Design rationale.................................................................................................................... 25&lt;/p&gt;
&lt;p&gt;
	2.5.3 Assumptions............................................................................................................................ 25&lt;/p&gt;
&lt;p&gt;
	Appendix A............................................................................................................... 26&lt;/p&gt;
&lt;p&gt;
	Databases or Flat file Data stores:.............................................................................................. 26&lt;/p&gt;
&lt;p&gt;
	Extensibility Scenarios........................................................................................................................ 30&lt;/p&gt;
&lt;p&gt;
	Data gatherer Extensibility.............................................................................................................. 33&lt;/p&gt;
&lt;p&gt;
	References............................................................................................................... 39&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
</ontowiki_WikiPage:content>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#20_Appendix_-_Centralized_Data_schema_for_all_gathered_information -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;20_Appendix_-_Centralized_Data_schema_for_all_gathered_information">
        <rdf:type rdf:resource="&UvA-SA-ontology;WikiPage"/>
        <rdfs:label>20 Appendix - Centralized Data schema for all gathered information</rdfs:label>
        <ontowiki_WikiPage:content>&lt;p&gt;
	&lt;strong&gt;Centralized Data schema for all gathered information&amp;rsquo;s:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
	What does a centralized data schema means in this context? For the data collector there 2 existing ways to store the extracted data from the different data sources (tool types).&amp;nbsp; One is to store the data in one global database schema, with tables for every tool type, for example a table for the transformed SVN data from the SVN gatherer.&lt;/p&gt;
&lt;p&gt;
	&amp;lt;picture&amp;gt;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;Advantages:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
	It is simple to administrate.&lt;/p&gt;
&lt;p&gt;
	Not a lot of server performance used compared with the decentralized version.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;Disadvantages:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
	Can form a bottleneck if too many operations are executed on the schema.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;Decentralized Data schema for all gathered information&amp;rsquo;s:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
	&amp;lt;picture&amp;gt;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;Advantages:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
	Separation of concerns, every type has its own schema.&lt;/p&gt;
&lt;p&gt;
	Better backup strategies possible, per schema for example.&lt;/p&gt;
&lt;p&gt;
	Better extensibility, for example if more load occurs as expected the schemas could easily moved to an extra database server.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;Disadvantages:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
	Small overhead for the Database system.&lt;/p&gt;
&lt;p&gt;
	Small overhead for the database administrator.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;Conclusion:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
	To store the collected raw data in databases per system brings an extra boost in performance and parallel working abilities. But more it brings extra advantages in the administration and security side. It extends the possibility to move the schemas on different servers, if the load is more than expected, or even if one server moves to another. Further it brings separation of concern in the database schemas, so the backups could be planned per tool type and its database. A downside is it asks more administration needs then the one schema solution.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;Decision:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
	The decision is to use a database schema for every tool type. This decision is based on the conclusion above. The database schema per tool type brings the needed extensibility also on the administration side. It also brings flexibility in moving the schemas or even to delete them when no data Gatherer for this type exists.&lt;/p&gt;
</ontowiki_WikiPage:content>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#21_Appendix_-_Data_gathering_scenario -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;21_Appendix_-_Data_gathering_scenario">
        <rdf:type rdf:resource="&UvA-SA-ontology;WikiPage"/>
        <rdfs:label>21 Appendix - Data gathering scenario</rdfs:label>
        <ontowiki_WikiPage:content>&lt;p&gt;
	&lt;strong&gt;Data gathering scenario:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;The 2 gathering options:&lt;/strong&gt;&lt;/p&gt;
&lt;table border=&quot;1&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot;&gt;
	&lt;tbody&gt;
		&lt;tr&gt;
			&lt;td style=&quot;width:26px;&quot;&gt;
				&lt;p&gt;
					&amp;nbsp;&lt;/p&gt;
			&lt;/td&gt;
			&lt;td style=&quot;width:274px;&quot;&gt;
				&lt;p&gt;
					&lt;strong&gt;Options&lt;/strong&gt;&lt;/p&gt;
			&lt;/td&gt;
			&lt;td style=&quot;width:262px;&quot;&gt;
				&lt;p&gt;
					&lt;strong&gt;Generalized options&lt;/strong&gt;&lt;/p&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;width:26px;&quot;&gt;
				&lt;p&gt;
					&lt;strong&gt;1&lt;/strong&gt;&lt;/p&gt;
			&lt;/td&gt;
			&lt;td style=&quot;width:274px;&quot;&gt;
				&lt;p&gt;
					Periodic listening, on changes for example in the SVN case listening for a commit.&lt;/p&gt;
			&lt;/td&gt;
			&lt;td style=&quot;width:262px;&quot;&gt;
				&lt;p&gt;
					A Listening component needs an extra module in the target systems.&lt;/p&gt;
				&lt;p&gt;
					For further use we call it, periodic listening.&lt;/p&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;width:26px;&quot;&gt;
				&lt;p&gt;
					&lt;strong&gt;2&lt;/strong&gt;&lt;/p&gt;
			&lt;/td&gt;
			&lt;td style=&quot;width:274px;&quot;&gt;
				&lt;p&gt;
					Using different libraries, API&amp;rsquo;S or connector per tool type. This will be also periodically.&lt;/p&gt;
			&lt;/td&gt;
			&lt;td style=&quot;width:262px;&quot;&gt;
				&lt;p&gt;
					Database connection, SOA interface to gather the data directly from the database, or a SVN library to gather the SVN stats.&lt;/p&gt;
				&lt;p&gt;
					For further use we call it, periodic queries.&lt;/p&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;
	The options above can be also applied on the other system adaptors.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;Advantages between periodic listening and periodic queries:&lt;/strong&gt;&lt;/p&gt;
&lt;table border=&quot;1&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot;&gt;
	&lt;tbody&gt;
		&lt;tr&gt;
			&lt;td colspan=&quot;2&quot; style=&quot;width:281px;&quot;&gt;
				&lt;p&gt;
					&lt;strong&gt;Periodic listening&lt;/strong&gt;&lt;/p&gt;
			&lt;/td&gt;
			&lt;td colspan=&quot;2&quot; style=&quot;width:281px;&quot;&gt;
				&lt;p&gt;
					&lt;strong&gt;Periodically direct queries&lt;/strong&gt;&lt;/p&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;width:130px;&quot;&gt;
				&lt;p&gt;
					&lt;strong&gt;Advantage&lt;/strong&gt;&lt;/p&gt;
			&lt;/td&gt;
			&lt;td style=&quot;width:151px;&quot;&gt;
				&lt;p&gt;
					&lt;strong&gt;Description&lt;/strong&gt;&lt;/p&gt;
			&lt;/td&gt;
			&lt;td style=&quot;width:123px;&quot;&gt;
				&lt;p&gt;
					&lt;strong&gt;Advantage&lt;/strong&gt;&lt;/p&gt;
			&lt;/td&gt;
			&lt;td style=&quot;width:159px;&quot;&gt;
				&lt;p&gt;
					&lt;strong&gt;Description&lt;/strong&gt;&lt;/p&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;width:130px;&quot;&gt;
				&lt;p&gt;
					Small requests&lt;/p&gt;
			&lt;/td&gt;
			&lt;td style=&quot;width:151px;&quot;&gt;
				&lt;p&gt;
					To listen on commits produce only small requests.&lt;/p&gt;
			&lt;/td&gt;
			&lt;td style=&quot;width:123px;&quot;&gt;
				&lt;p&gt;
					Use of given and common ways to query the source systems.&lt;/p&gt;
			&lt;/td&gt;
			&lt;td style=&quot;width:159px;&quot;&gt;
				&lt;p&gt;
					For example with direct database connections, or a SVN library to gather the stats.&lt;/p&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;width:130px;&quot;&gt;
				&lt;p&gt;
					&amp;nbsp;&lt;/p&gt;
			&lt;/td&gt;
			&lt;td style=&quot;width:151px;&quot;&gt;
				&lt;p&gt;
					&amp;nbsp;&lt;/p&gt;
			&lt;/td&gt;
			&lt;td style=&quot;width:123px;&quot;&gt;
				&lt;p&gt;
					Free libraries and connectors mostly given.&lt;/p&gt;
			&lt;/td&gt;
			&lt;td style=&quot;width:159px;&quot;&gt;
				&lt;p&gt;
					The SVN or database connectors for open source systems are mostly free to use.&lt;/p&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	Disadvantages between periodic listening and periodic queries:&lt;/p&gt;
&lt;table border=&quot;1&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot;&gt;
	&lt;tbody&gt;
		&lt;tr&gt;
			&lt;td colspan=&quot;2&quot; style=&quot;width:285px;&quot;&gt;
				&lt;p&gt;
					&lt;strong&gt;Periodic listening&lt;/strong&gt;&lt;/p&gt;
			&lt;/td&gt;
			&lt;td colspan=&quot;2&quot; style=&quot;width:283px;&quot;&gt;
				&lt;p&gt;
					&lt;strong&gt;Periodically direct queries&lt;/strong&gt;&lt;/p&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;width:130px;&quot;&gt;
				&lt;p&gt;
					&lt;strong&gt;Disadvantage&lt;/strong&gt;&lt;/p&gt;
			&lt;/td&gt;
			&lt;td style=&quot;width:155px;&quot;&gt;
				&lt;p&gt;
					&lt;strong&gt;Description&lt;/strong&gt;&lt;/p&gt;
			&lt;/td&gt;
			&lt;td style=&quot;width:119px;&quot;&gt;
				&lt;p&gt;
					&lt;strong&gt;Disadvantage&lt;/strong&gt;&lt;/p&gt;
			&lt;/td&gt;
			&lt;td style=&quot;width:164px;&quot;&gt;
				&lt;p&gt;
					&lt;strong&gt;Description&lt;/strong&gt;&lt;/p&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;width:130px;&quot;&gt;
				&lt;p&gt;
					A lot of requests to gather the needed information.&lt;/p&gt;
			&lt;/td&gt;
			&lt;td style=&quot;width:155px;&quot;&gt;
				&lt;p&gt;
					Produces overhead.&lt;/p&gt;
			&lt;/td&gt;
			&lt;td style=&quot;width:119px;&quot;&gt;
				&lt;p&gt;
					Need change for data access changes&lt;/p&gt;
			&lt;/td&gt;
			&lt;td style=&quot;width:164px;&quot;&gt;
				&lt;p&gt;
					For example when the wiki always used a MYSQL database and the database gets changed to ORACLE the connector needs to be reconfigured.&lt;/p&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;width:130px;&quot;&gt;
				&lt;p&gt;
					In other cases an extra plug-in need to be installed in the source systems to listen on changes.&lt;/p&gt;
			&lt;/td&gt;
			&lt;td style=&quot;width:155px;&quot;&gt;
				&lt;p&gt;
					Produces overhead and extra costs and administration for the administrator of the system. (Updates etc.)&lt;/p&gt;
			&lt;/td&gt;
			&lt;td style=&quot;width:119px;&quot;&gt;
				&lt;p&gt;
					-&lt;/p&gt;
			&lt;/td&gt;
			&lt;td style=&quot;width:164px;&quot;&gt;
				&lt;p&gt;
					-&lt;/p&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;Conclusion:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
	The conclusion is to use the query variant, because it uses given technologies without needed changes on the source systems. These techniques can be used for every source system. For example for the SVN with a simulated client or API calls, or in the WIKI case with read access on the Node database structure from the WIKI database.&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;Decision:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
	The second option the periodic query option can be used for every SVN server, Database or given API from the source systems and its fits the requested extensibility attribute. Can be used for SVN and in this range for every SVN related Server implementation. Mature Lib&amp;#39;s are available to provide a secure and reliable wayretrieving data from SVN Repositories, databases or email, IRC communication channels. The use of connector classes can be made configurable to eliminate the named disadvantage for this option.&lt;/p&gt;
</ontowiki_WikiPage:content>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#21_Appendix_-_Extensibility_scenario -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;21_Appendix_-_Extensibility_scenario">
        <rdf:type rdf:resource="&UvA-SA-ontology;WikiPage"/>
        <rdfs:label>22 Appendix - Extensibility scenario</rdfs:label>
        <ontowiki_WikiPage:content>&lt;h2&gt;
	Extensibility Scenarios&lt;/h2&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;&lt;em&gt;Current fit&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
	Within this scenario, the application is fitted to the current system. This means that the application is tightly coupled to the current infrastructure of the organization.&lt;/p&gt;
&lt;p&gt;
	For instance, the organization currently uses Mercurial for version control. In this scenario the application is tightly fitted to this version control system. If a new version control system is going to be used by the organization, the internal structure of the application needs to be modified.&lt;/p&gt;
&lt;p&gt;
	&lt;br /&gt;
	&lt;strong&gt;&lt;em&gt;Partly extensible&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
	In this scenario, the data sources are categorized. For instance, there is a category &lt;em&gt;version control&lt;/em&gt;, a category &lt;em&gt;contact&lt;/em&gt;, etc. All these categories provide an abstract data representation and an interface for the concrete implementation.&lt;/p&gt;
&lt;p&gt;
	Let&amp;rsquo;s continue with the version control sample. A commit to the version control system can be represented by a commit message and a set of changed files. This representation is isn&amp;rsquo;t coupled to a specific version control system because all systems share this signature, so this can be used to represent a commit, independent of the concrete implementation.&lt;/p&gt;
&lt;p&gt;
	Secondly, the type defines an interface which the concrete data source needs to implement. This way, the concrete data source can be used but the system itself uses the abstract interface to call the data source. The system doesn&amp;rsquo;t need to know the specific data source to operate, because it operates on the interface.&lt;/p&gt;
&lt;p&gt;
	This way, it is possible to switch the concrete data source of the current type, without the need to modify the internal structure of the system. Of course, the new data source has to be implemented within the application, but after that, it can be &lt;em&gt;plugged &lt;/em&gt;into the application, without the need to modify the internal structure of the system. Within object oriented programming, this is often referred to as the Adapter Design Pattern.&lt;/p&gt;
&lt;p&gt;
	When a completely new data source has to be implemented, for which there currently isn&amp;rsquo;t a type defined, the internal structure of the application still needs to be modified.&lt;br /&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;&lt;em&gt;Fully extensible&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
	In this scenario, the application is built in a way that new data sources can be added regardless of type. The application provides an interface for new data sources which needs to be implemented and after that, the new data source can be plugged in. The internal structure doesn&amp;rsquo;t have to be modified for any new data sources.&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;Considerations&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
	Each scenario has its advantages and disadvantages which have to be weighed against each other.&lt;br /&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;&lt;em&gt;Extensibility&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
	If we look at extensibility, we see that the fully extensible-solution is the most extensible, like the name already says. It can be fully extended with different types of data sources.&lt;/p&gt;
&lt;p&gt;
	The partly extensible-solution is also extensible, but more in a focused way. A new data source can be included, however the type of data source needs to be defined within the application already. For example, a new type of version control system can be included without changing the internal structure of the application, but for a completely new type of data source, the internal structure has to be modified to support this type of data source.&lt;/p&gt;
&lt;p&gt;
	The first solution isn&amp;rsquo;t extensible, because it is fitted to the current infrastructure of the organization. When a new data source is introduced, it has to be fitted to the application as well.&lt;br /&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;&lt;em&gt;Cost and complexity&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
	The current fit-solution is not complex, relative to the other solutions, because there aren&amp;rsquo;t any abstractions. The implementations are tightly coupled in the system which makes the application pretty simple.&lt;/p&gt;
&lt;p&gt;
	The partly extensible-solution has abstractions on the type level, which makes it more complex compared to the current fit-solution. This is because the abstractions have to be researched and a general data representation has to be developed. This raises the complexity.&lt;/p&gt;
&lt;p&gt;
	The fully extensible-solution is even more complex, because the abstractions are at the data source level. Because of this, within the application there isn&amp;rsquo;t a structure available for types of data, in contrast to the partly extensible solution. This means that the application has to be able to handle every type of data, which raises the complexity a lot.&lt;/p&gt;
&lt;p&gt;
	When the complexity of a system rises, so does the development time because if the solution is more complex, more time goes into research, design and development. More development time means more development costs. Because of this, the complexity of the application is proportional to the cost of the application.&lt;br /&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;&lt;em&gt;Deployment&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
	All solutions have to be configured because they need to be connected to the data sources. It is practically impossible to develop a solution which runs completely out of the box, because there is the necessity to authenticate the application with the external systems, etc. Also, before the application can be used it has to be included within the internal network of the organization because otherwise no one is able to access it and the application itself can&amp;rsquo;t access the other systems. Because this statement holds for all scenarios, we won&amp;rsquo;t take this configuration into consideration, but we will only look at the work which is necessary relative to the other solutions.&lt;/p&gt;
&lt;p&gt;
	If we look at the first solution, we see that it is easy to deploy. Only the initial configuration is needed to fit it to the systems within the organization, and no other configuration is needed.&lt;/p&gt;
&lt;p&gt;
	The second solution is more difficult to deploy because apart from the specific data source configuration, also the type of data source has to be configured. For instance, the application will not know out of the blue which instance of a version control system used or even how many version control systems are in operation within the organization, so this needs to be configured.&lt;/p&gt;
&lt;p&gt;
	Lastly, the third solution requires a lot of configuration to fit it to the different data sources. Data models need to be configured and the translation between the data from the data sources and the data models needs to be defined. Because of this, the deployment of this solution is the most complex.&lt;/p&gt;
&lt;h5&gt;
	&lt;strong&gt;Comparison&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;
	To compare the attributes named above, we have included them in a table below and scored them.&lt;/p&gt;
&lt;table align=&quot;center&quot; border=&quot;1&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot;&gt;
	&lt;tbody&gt;
		&lt;tr&gt;
			&lt;td style=&quot;width:109px;&quot;&gt;
				&lt;p&gt;
					&amp;nbsp;&lt;/p&gt;
			&lt;/td&gt;
			&lt;td style=&quot;width:83px;&quot;&gt;
				&lt;p align=&quot;center&quot;&gt;
					Current fit&lt;/p&gt;
			&lt;/td&gt;
			&lt;td style=&quot;width:121px;&quot;&gt;
				&lt;p align=&quot;center&quot;&gt;
					Partly extensible&lt;/p&gt;
			&lt;/td&gt;
			&lt;td style=&quot;width:114px;&quot;&gt;
				&lt;p align=&quot;center&quot;&gt;
					Fully extensible&lt;/p&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;width:109px;&quot;&gt;
				&lt;p align=&quot;right&quot;&gt;
					Extensibility&lt;/p&gt;
			&lt;/td&gt;
			&lt;td style=&quot;width:83px;&quot;&gt;
				&lt;p align=&quot;center&quot;&gt;
					--&lt;/p&gt;
			&lt;/td&gt;
			&lt;td style=&quot;width:121px;&quot;&gt;
				&lt;p align=&quot;center&quot;&gt;
					+&lt;/p&gt;
			&lt;/td&gt;
			&lt;td style=&quot;width:114px;&quot;&gt;
				&lt;p align=&quot;center&quot;&gt;
					++&lt;/p&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;width:109px;&quot;&gt;
				&lt;p align=&quot;right&quot;&gt;
					Cost&lt;/p&gt;
			&lt;/td&gt;
			&lt;td style=&quot;width:83px;&quot;&gt;
				&lt;p align=&quot;center&quot;&gt;
					+&lt;/p&gt;
			&lt;/td&gt;
			&lt;td style=&quot;width:121px;&quot;&gt;
				&lt;p align=&quot;center&quot;&gt;
					+/-&lt;/p&gt;
			&lt;/td&gt;
			&lt;td style=&quot;width:114px;&quot;&gt;
				&lt;p align=&quot;center&quot;&gt;
					--&lt;/p&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;width:109px;&quot;&gt;
				&lt;p align=&quot;right&quot;&gt;
					Complexity&lt;/p&gt;
			&lt;/td&gt;
			&lt;td style=&quot;width:83px;&quot;&gt;
				&lt;p align=&quot;center&quot;&gt;
					+&lt;/p&gt;
			&lt;/td&gt;
			&lt;td style=&quot;width:121px;&quot;&gt;
				&lt;p align=&quot;center&quot;&gt;
					+/-&lt;/p&gt;
			&lt;/td&gt;
			&lt;td style=&quot;width:114px;&quot;&gt;
				&lt;p align=&quot;center&quot;&gt;
					--&lt;/p&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;width:109px;&quot;&gt;
				&lt;p align=&quot;right&quot;&gt;
					Deployment&lt;/p&gt;
			&lt;/td&gt;
			&lt;td style=&quot;width:83px;&quot;&gt;
				&lt;p align=&quot;center&quot;&gt;
					++&lt;/p&gt;
			&lt;/td&gt;
			&lt;td style=&quot;width:121px;&quot;&gt;
				&lt;p align=&quot;center&quot;&gt;
					+/-&lt;/p&gt;
			&lt;/td&gt;
			&lt;td style=&quot;width:114px;&quot;&gt;
				&lt;p align=&quot;center&quot;&gt;
					--&lt;/p&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/tbody&gt;
&lt;/table&gt;
&lt;div style=&quot;clear:both;&quot;&gt;
	&amp;nbsp;&lt;/div&gt;
&lt;p&gt;
	&lt;strong&gt;&lt;em&gt;Stakeholder profile and stakeholder feedback&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
	&lt;br /&gt;
	The stakeholders indicated that they want to use the latest tools and techniques to use with their projects. If we look at the history of the company of the stakeholders, we see that they indeed switch their tools once in a while. However, they actually switch tools, and don&amp;rsquo;t add tools which they didn&amp;rsquo;t use before.&lt;/p&gt;
&lt;p&gt;
	To double check, we asked the stakeholders how they foresee the use of tools in the future. They indeed verified that when they introduce a new tool, it is often to replace existing tools and not to introduce a completely new tool. They also indicated that there currently isn&amp;rsquo;t a need to introduce a completely new tool into the organization.&lt;/p&gt;
</ontowiki_WikiPage:content>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#22_Appendix_-_Data_gatherer_extensibility -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;22_Appendix_-_Data_gatherer_extensibility">
        <rdf:type rdf:resource="&UvA-SA-ontology;WikiPage"/>
        <rdfs:label>22 Appendix - Data gatherer extensibility</rdfs:label>
        <ontowiki_WikiPage:content>&lt;h2&gt;
	Data gatherer Extensibility&lt;/h2&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	In this chapter, an example has been laid out, which shows how the application could react to such a change. The example focuses on version control systems, but the general idea is applicable for all types.&lt;/p&gt;
&lt;p&gt;
	It should be noted that this is just an example to show extensibility and not a definite design of the application.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;ETL&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	On the level of the data sources, we are using the ETL architectural pattern. ETL stands for &lt;em&gt;Extraction&lt;/em&gt;, &lt;em&gt;Transformation&lt;/em&gt; and &lt;em&gt;Load&lt;/em&gt;. In the extraction step, the external system is queried for data. Thereafter, the extracted data is transformed into a representation used within our system for the specific type. Finally, the transformed data is saved into the data store.&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;
	[picture]&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;
	Figure 1Internal representation of a commit from a version control system&lt;/p&gt;
&lt;p&gt;
	The extraction and transformation step have to be specified for each specific version control system. Connecting to a version control system is specific to that system, because it has to use itsAPI. Also the transformation step has to be specified for each system, because the data retrieved from the API differs between the systems.&lt;/p&gt;
&lt;p&gt;
	However, because the transformation step transforms the data into a format which is shared because all implementations of the version control system type, the load-step doesn&amp;rsquo;t have to be specific for each implementation. The component which handles the saving of the data can be shared by all implementations of version control systems.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;Extensibility&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	Like described in the previous paragraph, the change for each system is localized in two processes: the retrieval of the commit data from a specific version control system, and the transformation of this data to the representation used within the system. When a new implementation of the version control system type has to be implemented, we want to localize this new implementation as much as possible to make it easy to add a new version control system and to avoid having to duplicate functionality which is already implemented in another implementation.&lt;/p&gt;
&lt;p&gt;
	To achieve this, we have come up with the following solution.&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;
	[picture]&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;
	Figure 2Interfaces for extracting and transforming data from a version control system&lt;/p&gt;
&lt;p&gt;
	When a new system needs to&amp;nbsp; be added, the implementation of the system has to implement these three interfaces. The IExtractor and ITransformerboth need to be implemented to provide the extraction and transformation details for the specific version control system. The IAbstractFactory interface subsequently needs to be implemented to create instances of both the IExtractor and ITransformer interfaces.&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;
	[picture]&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;
	Figure 3Implementation for Mercurial&lt;/p&gt;
&lt;p&gt;
	To use an implementation, the specific instance of IAbstractFactory has to be registered somewhere. This could done from within code or from a configuration file for maximum flexibility. The application will then use the instances retrieved from the IAbstractFactory to get data from the external system and transform this data.&lt;/p&gt;
&lt;br clear=&quot;all&quot; /&gt;
&lt;p&gt;
	[picture]&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;
	Figure 4Creation and use of extractor and transformer&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
</ontowiki_WikiPage:content>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#23_Appendix_-_Push_and_Pull_data -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;23_Appendix_-_Push_and_Pull_data">
        <rdf:type rdf:resource="&UvA-SA-ontology;WikiPage"/>
        <rdfs:label>23 Appendix - Push and Pull data</rdfs:label>
        <ontowiki_WikiPage:content>&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;Push data:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	The first solution we had considered was pushing data from one layer to another when ready up to the data storage at the end. If performed very puristicly, the data extractors wouldn&amp;rsquo;t so much be extractors but API&amp;rsquo;s that are able to receive data from the appropriate sources. A list of advantages (green) and disadvantages (red) are listed in this section.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;&lt;em&gt;(Dis) advantages&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	A big advantage of using a puristic push-technique is the fact that you essentially lay the control of &lt;em&gt;when&lt;/em&gt; to push data to the data extractors to the tool the data comes from. The stakeholders have reported that these systems are critical and must in now way be harmed by a system such as this one that is not.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	By laying the control at the critical applications, they can decide when to push the data. They could wait for a moment in which they&amp;rsquo;re less busy and do it then. This is a very easy method to ensure the processes are not run at an inconvenient time.&lt;/p&gt;
&lt;br clear=&quot;all&quot; /&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	The flipside of the coin is that this solution offers no possibility to decide when to receive data from what sources, troubling the data coupling process later on. This would essentially mean that all data should we coupled at database level and not programmatically.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	As stated before, this solution is not possible for all application types. SVN for example offers possibilities to implement post-commit hooks but another system may not. This could seriously limit the possible data-providing systems we can work with.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;Pull data:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;&lt;em&gt;(Dis) advantages&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	This strategy offers the possibility to have complete control over when to receive data from what sources. The advantage of this strategy is the fact that more data can be pre-coupled before persisted to the final database.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	Another big advantage is the fact that unlike with the push-strategy a pull-strategy is possible with every application so long as they have a way to retrieve data from it such as an API or a log file. This means that the amount of possible applications that can connect with our application is much larger.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	A disadvantage of the pull-strategy is the fact that deciding when to retrieve data from the critical systems is not at all trivial, sincethe data extractors some way to analyse whether or not the external critical system is quite busy at the moment. This could be overcome with some monitoring software however.&lt;/p&gt;
</ontowiki_WikiPage:content>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#24_Appendix_-_hardcoded_rules_and_business_engine -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;24_Appendix_-_hardcoded_rules_and_business_engine">
        <rdf:type rdf:resource="&UvA-SA-ontology;WikiPage"/>
        <rdfs:label>24 Appendix - hardcoded rules and business engine</rdfs:label>
        <ontowiki_WikiPage:content>&lt;p&gt;
	&lt;strong&gt;Hard coded rules:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	This section describes the disadvantages and advantages of hard coded rules. The points are taken into consideration about a needed decision.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;&lt;em&gt;(Dis) advantages&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	If the logic is hard-coded, there is no need for another external module to communicate with. This means that there are fewer dependencies to take into account making the system as a whole a bit less complex. The business logic layer however would grow larger and get more complex when choosing this strategy. By hard-coding the rules, we can assure that the necessary rules are always present.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	A big disadvantage of a solution with hard-coded rule is the fact that it would accommodate very few possibilities for maintainability. These types of rules are generally not set in stone; initial values are estimated but may change over time when insights progress. A hard-coded solution is terrible for doing that, since the code has to be adapted every time a rule changes. In case of a system that runs in a compiled language, it also needs to be reset.&lt;/p&gt;
&lt;br clear=&quot;all&quot; /&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;Business rules engines:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	This section describes the disadvantages and advantages of the business rules engine. The points are taken into consideration about a needed decision.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;&lt;em&gt;(Dis) advantages&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	A business rules engine is a generic module that can depend on rules from an external source, such as a text file or database. This is much more straightforward then editing the source code every time a rule changes.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	Anybody can edit a text file, or possibly use a UI to enter these rules but not everybody knows how to edit code. Also since these external files/databases need not compile it&amp;rsquo;s possible to adapt rules at runtime. Availability is not a major concern of the stakeholders, but it still reduces the amount of work that is needed which is something pointing out.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	Another advantage of this solution is the fact that this is an industry-grade solution for a common problem. Rather than re-inventing the wheel, a solution like this can be used which is convenient not only because there is probably a lot information available about the specific system on the internet, but also because odds are that developers have at least heard of the technique.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	A disadvantage is the fact that the introduction of an extra module makes the system as a whole a bit more complex. However, the code in the application itself can be kept a lot cleaner.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;Conclusion:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	The latter solution is more fit for the problem in our opinion, because of the straight-forwardness of rule adaption as well as the fact that it&amp;rsquo;s an industry-standard practice. The fact that it introduces a bit of complexity is not reason enough to discard the idea, especially since the alternative does the same in a different space.&lt;/p&gt;
</ontowiki_WikiPage:content>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#26_Appendix_-_relational_and_graph_database_systems -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;26_Appendix_-_relational_and_graph_database_systems">
        <rdf:type rdf:resource="&UvA-SA-ontology;WikiPage"/>
        <rdfs:label>25 Appendix - relational and graph database systems</rdfs:label>
        <ontowiki_WikiPage:content>&lt;p&gt;
	&lt;strong&gt;Relational Database system:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;Dis (advantages)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
	Relational databases have been around since the 1970s and are to this day the mostly used database type available. Lots of mature commercial as well as open-source implementations exist. High quality tooling exists which enables optimization or monitoring. To put it straight, the relational database has withstood the test of time and is probably not going anywhere anytime soon.&lt;/p&gt;
&lt;p&gt;
	Related to the fact that these databases have been around for so much time, the community has had plenty of time to familiarize itself with the subject. Most developers have at least a basic understanding of SQL and there is plenty of information to find on the subject online.&lt;/p&gt;
&lt;p&gt;
	A disadvantage of the relational databases is the fact that the data is divided into several tables, which sometimes have to be joined together. This takes a lot of time if the data size grows larger. We would have to have a separate query for each user to check the other users it&amp;rsquo;s connected with. In a high-density network that may develop overtime, this will cost more and more performance.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;Graph Database system:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;Dis (advantages)&lt;/strong&gt;&lt;br /&gt;
	The huge advantage of graph databases over relational databases is the performance gain when querying relationships between nodes. Since this is the prime functionality for a system such as this it can be used to meet the high performance demands that the stakeholders require from it.&lt;/p&gt;
&lt;p&gt;
	Contrary to the relational databases, the technology has not been around for quite as long. This results in the fact that the amounts of developers that have a basic understanding of the concept are quite a lot slimmer than with relational databases. However, there are some implementations with an active user community such as Neo4j.&lt;/p&gt;
&lt;p&gt;
	Big companies such as Google, Facebook and LinkedIn also use graph databases for their social networking data storage. This is good news for the field&amp;rsquo;s further development as these companies have the funds to support new research.&lt;/p&gt;
&lt;p&gt;
	A further disadvantage is the fact that data storage takes 1.5 to 2 times as much room on a hard disk than in a relational database. This is not too much of an issue, since hard disk is very cheap nowadays but it is something worth mentioning.&lt;/p&gt;
</ontowiki_WikiPage:content>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#26_references -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;26_references">
        <rdf:type rdf:resource="&UvA-SA-ontology;WikiPage"/>
        <rdfs:label>26 references</rdfs:label>
        <ontowiki_WikiPage:content>&lt;h1&gt;
	&amp;nbsp;References&lt;/h1&gt;
&lt;p&gt;
	[1] C. Vicknair, M. Macias, Z. Zhao, X. Nan, Y. Chen and D. Wilkins, &amp;quot;A comparison of a graph database and a relational database: A data provenance perspective,&amp;quot; in &lt;em&gt;Proceedings of the 48th Annual Southeast Regional Conference, &lt;/em&gt;2010, pp. 42.&lt;/p&gt;
</ontowiki_WikiPage:content>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#2_logical_and_implementation_view_-_primary_presentation -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;2_logical_and_implementation_view_-_primary_presentation">
        <rdf:type rdf:resource="&UvA-SA-ontology;WikiPage"/>
        <rdfs:label>2 logical and implementation view - primary presentation</rdfs:label>
        <ontowiki_WikiPage:content>&lt;h1&gt;
	1.Logical &amp;amp; Implementation view&lt;/h1&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	This chapter contains our logical and implementation view on the SNA system for Previous. It explains our thoughts on the functionality that should be made available in this system, using a graphical representation of the view, along with explanations in various sections.&lt;/p&gt;
&lt;h2&gt;
	1.1 Primary presentation of the view&lt;/h2&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	In this section, a representation of the logical and implementation view is shown in a graphical way. We used a component model to show which components should be present in the system in order to meet functional requirements that determine the quality of the system. These requirements will be explained in later sections.&lt;/p&gt;
</ontowiki_WikiPage:content>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#3_logical_and_implementation_view_-_element_catalog -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;3_logical_and_implementation_view_-_element_catalog">
        <rdf:type rdf:resource="&UvA-SA-ontology;WikiPage"/>
        <rdfs:label>3 logical and implementation view - element catalog</rdfs:label>
        <ontowiki_WikiPage:content>&lt;h2&gt;
	&lt;br /&gt;
	1.2 Element Catalog&lt;/h2&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	In this section, we will explain globally the terminology used in our views. This section is used as a legend to our logical and implementation view, and it explains what each component in the component model of 1.1, in essence, represents.&lt;/p&gt;
&lt;br clear=&quot;all&quot; /&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	This section is divided into 4 subsections:&lt;/p&gt;
&lt;p style=&quot;margin-left:72.0pt;&quot;&gt;
	&amp;middot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Elements and their properties&lt;/p&gt;
&lt;p style=&quot;margin-left:72.0pt;&quot;&gt;
	&amp;middot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Relations and their properties&lt;/p&gt;
&lt;p style=&quot;margin-left:72.0pt;&quot;&gt;
	&amp;middot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Element interfaces&lt;/p&gt;
&lt;p style=&quot;margin-left:72.0pt;&quot;&gt;
	&amp;middot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Element behaviour&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	Each of these subsections will explain the component model shown in 1.1 in more detail.&lt;/p&gt;
&lt;h3&gt;
	1.2.1 Elements and their properties&lt;/h3&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	Our logical and implementation view consists of 3 layers: A data layer, a business logic layer and a representation layer. The data layer is the layer that accommodates the gathering of data from the various project assisting tools used by Previous. The business logic layer contains the transformation of the initially gathered data to a format that is more easily accessible and analysable, which is accomplished by a set of business rules as defined by users. The representation layer contains the way of representing the results of the analysis to the users.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	In this section we will describe the definition of each component within each layer in the coming subsections.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;Data layer&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;Tool type:&lt;/strong&gt;A &amp;ldquo;tool type&amp;rdquo; is a type of software development project supporting tool used by Previous. A few examples of tool types we have identified within Previous are: &amp;ldquo;Versioning tools&amp;rdquo; (such as: SVN, Mercurial), &amp;ldquo;Communication tools&amp;rdquo; (such as: Mail, IRC), &amp;ldquo;Project management tools&amp;rdquo; (such as: JIRA, Redmine) and &amp;ldquo;Bugtracking tools&amp;rdquo; (such as: Bugzilla).&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;Extractor: &lt;/strong&gt;The extractor within the data layer is a component that connects to a tool&amp;rsquo;s (an instance of a tool type) data source. After successfully establishing a connection, it will extract all of the available data from the tool as long as that data wasn&amp;rsquo;t included in any previous extraction. This extraction can happen at a scheduled interval, which can either be determined by a learning system or a fixed schedule, or it happens through a push mechanism (whenever data in a tool gets updated, extract the data).&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;Transformer: &lt;/strong&gt;The transformer component will make modifications to the data it receives so that it can be mapped for storage in a relational database. The structuring of the data is determined by the tool type information that should be provided.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;Business logic layer&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;Extractor:&lt;/strong&gt;The extractor in this layer is of a similar concept to the extractor at the data layer, except that this extractor is used to extract data from the relational database, which will then be used by a different transformer. A business rules engine determines which data fields the extractor should extract.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;Transformer:&lt;/strong&gt;The transformer in this layer uses the data from this layer&amp;rsquo;s extractor, along with business rules set in the business rules engine in order to transform the data from the relational database into a format accepted by the analysis database. This analysis database will most likely be a graph database (as explained later on in this chapter). This means that the transformer has the following 2 jobs: 1) convert the data from the relational database into a format accepted by the graph database and 2) derivations and aggregations must be made on the data.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;Business rules engine:&lt;/strong&gt;The business rule engine contains a set of business rules that are used for decision making and derivation of information from the data in the relational database. These rules can be set by the users via the configurations module. These business rules can contain for example: &amp;lt;If a user has committed more than 10 .java files, user is an expert on Java&amp;gt;. These business rules will influence the transformer and extractor components, as the extractor must derive from the business rules which data fields to extract from the relational database, while the transformer must transform this data accordingly.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;Configuration Module (UI):&lt;/strong&gt;The configuration module is a module for users to give their input on the conversion of data. As architect it&amp;rsquo;s hard to determine which queries are necessary for the system to be useful. Next to that, it&amp;rsquo;s also hard to determine how often these queries will change. Therefore, we decided to create a module where users can decide which data gets converted into which format and which significance each piece of data gets. This way, the user is in full control over their data.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;Representation layer&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;API:&lt;/strong&gt;The API is a web service that allows one to consult the analysis database. This API will contain a few prefixed queries that can be used for reporting purposes and also contains a free-form part, with which users can construct their own queries. This API can then be used in various client-side applications, such as a report generator or a web client.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;Various client components:&lt;/strong&gt;Based on Previous&amp;rsquo; wish, it is possible to create multiple front-ends. All of these front-ends (clients) will use the API for their data access. The design of each client is therefore not important for the overall architecture, as Previous has yet to decide the types of front-ends they would like to use and the API is in all cases the central building block to each front-end.&lt;/p&gt;
&lt;br clear=&quot;all&quot; /&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
</ontowiki_WikiPage:content>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#4_logical_and_implementation_view_-_relationships_and_properties -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;4_logical_and_implementation_view_-_relationships_and_properties">
        <rdf:type rdf:resource="&UvA-SA-ontology;WikiPage"/>
        <rdfs:label>4 logical and implementation view - relationships and properties</rdfs:label>
        <ontowiki_WikiPage:content>&lt;h3&gt;
	1.2.2 Relations and their properties&lt;/h3&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	The logical and implementation view is based on the concept of a layered architecture. This means that each &amp;ldquo;layer&amp;rdquo; in this architecture can communicate with the layer above or below, but not have any gaps of layers in between.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	Our logical and implementation view actually contains 5 layers: The data layer, business logic layer and representation layer, as well as 2 data access layers in between. These data access layers are the connection points between each layer. Below, the relations between each layer and their components are sketched.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	The relations between the layers are simple: Each layer passes data to the next layer, which either stores or transforms the data before passing it on to the next layer. Communication between layers only exists through the data access layers.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;Data layer&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	Within the data layer, the extractor component communicates with the various data stores of the tools used by previous. The extractor component does not directly communicate with any of these tools, but only accesses the data stored in each tool. We explicitly defined that the extractor should have the least interference with the existing tools as possible, because Previous stated that the &amp;ldquo;Facebook for software developers&amp;rdquo; will be used as a supporting tool. Our system must therefore interfere as little as possible with the current (process-critical) tools.&lt;/p&gt;
&lt;p&gt;
	The data layer acts as an independent part of the system, therefore user queries will not affect the process of data gathering from different tools. The extractor component will extract data based on a scheduler, which can either be a learning system in itself (to determine when the best time to collect data is, based on tool usage) or a simple scheduler (gather new data every hour/day/week).&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;Business logic layer&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	Communication within the business logic layer is split up into 2 data flows. One of these flows is the configuration of business rules, and the other the actual conversion, as depicted in our component model. The configuration module must connect to the relational database in order to make is visible for the user which data is available. Using this information, the user can determine which data fields are relevant for the queries they want to fire at the system, which is in turn stored and calculated in the business rules engine. The extractor and transformer must, based on the input from the business rules engine, extract and transform data from the relational database into the graph database.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	The business logic layer, the conversion of relational data to graph data, can either be based on a scheduling system (same as the data layer, making this an independent component) or based on user input (whenever a user fires a query, update the graph database).&lt;/p&gt;
&lt;br clear=&quot;all&quot; /&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	We have chosen to make this layer independent, as this system is not process-critical (therefore, data doesn&amp;rsquo;t need to be very accurate) and it would safe performance, which is one of the quality aspects the stakeholders are concerned about (they want a fast system, else it will probably not be used).&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;Representation layer&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	The representation layer is an API that accesses the graph database. This API contains methods for accessing data based on the business rules set in the business rules engine. Users can query the data using any user interface that implements the API. This way, Previous is free to choose whichever representation they&amp;rsquo;d like.&lt;/p&gt;
</ontowiki_WikiPage:content>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#5_logical_and_implementation_view_-_element_interfaces_and_behaviour -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;5_logical_and_implementation_view_-_element_interfaces_and_behaviour">
        <rdf:type rdf:resource="&UvA-SA-ontology;WikiPage"/>
        <rdfs:label>5 logical and implementation view - element interfaces and behaviour</rdfs:label>
        <ontowiki_WikiPage:content>&lt;h3&gt;
	1.2.3 Element interfaces&lt;/h3&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	Each layer of the system is an independent component and can be run in a different environment than the others. The only connection points are the data access layers. The only connection points are the data access layers which are used by two layers in a time. The only interface or contract between the two layers is the underlying data model, which gets written or read by each one of the systems. For example the data layer writes data and the business layer reads the data, both have the only contract which is the data model stored in the database the layers use. They layers itself don&amp;rsquo;t know each other, only the data access layer knows them both.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;h3&gt;
	1.2.4 Element behaviour&lt;/h3&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	In this subsection we give a high level representation of how a possible communication flow between components, which indicates system behaviour, could be realised. Each layer has its own communication flow and is started independently by a certain event. In case of the Data and Business Logic layer, this is a scheduler. In case of the Representation layer, this is a query fired by the user.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	We therefore decided to create 3 UML sequence diagrams in order to depict the communication flow within each component in each layer. We are using a more loose representation of this diagram, as we do not want to go into too much technical detail within the logical and implementation view. This diagram should therefore also be understandable for non-technical stakeholders.&lt;/p&gt;
&lt;br clear=&quot;all&quot; /&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;Data Layer:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;Business Logic Layer:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	Modifying business rules:&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;br clear=&quot;all&quot; /&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;Transforming data:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;Representation Layer:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;br clear=&quot;all&quot; /&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
</ontowiki_WikiPage:content>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#6_logical_and_implementation_view_-_context_diagram_and_variability_guide -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;6_logical_and_implementation_view_-_context_diagram_and_variability_guide">
        <rdf:type rdf:resource="&UvA-SA-ontology;WikiPage"/>
        <rdfs:label>6 logical and implementation view - context diagram and variability guide</rdfs:label>
        <ontowiki_WikiPage:content>&lt;h2&gt;
	1.3 Context diagram&lt;/h2&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	This section illustrates the positioning of our system within Previous&amp;rsquo; software systems.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;SNA System:&lt;/strong&gt;The &amp;ldquo;Facebook&amp;rdquo; for software developers&lt;/p&gt;
&lt;h2&gt;
	1.4 Variability guide&lt;/h2&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;Entering business rules&lt;br /&gt;
	&lt;br /&gt;
	&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
	One of the things that we&amp;rsquo;re not going to decide on right now is how to enter new business rules. This could be in a text file the business rules engine depends on, or in some sort of database. A user interface could be built or we could let developers edit the source directly. We feel this is too much of a detail to focus our attention on in this stage of the application&amp;rsquo;s development, it should be decided when the systems are being designed at a more fine-grained level.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
</ontowiki_WikiPage:content>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#7_logical_and_implementation_view_-_architecture_background_-_rationale_-_data_gathering -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;7_logical_and_implementation_view_-_architecture_background_-_rationale_-_data_gathering">
        <rdf:type rdf:resource="&UvA-SA-ontology;WikiPage"/>
        <rdfs:label>7 logical and implementation view - architecture background - rationale - data gathering</rdfs:label>
        <ontowiki_WikiPage:content>&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;
	1.5 Architecture background&lt;/h2&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;h3&gt;
	1.5.1 Design rationale&lt;/h3&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	In this chapter the decisions we made for the implementation and logical view on the architecture and the alternatives are described and weighted, and finally a strategy is chosen.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	First, we&amp;rsquo;ll discuss the decisions that have been made in the data layer of the application. This layer is responsible for retrieving, abstracting and aggregating data from multiple sources in preparation for the actual analysis of the data.&lt;br /&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;h4&gt;
	1.5.1.1 Data gathering layer&lt;/h4&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	The Data collector layer performs data collection tasks from several systems used by the customer.&lt;/p&gt;
&lt;p&gt;
	The data which needs to be collected are stored in several sub systems. The Data collector queries the subsystem and collects its newest data, to transform them in a simple format for the SNA Layer to perform analytic tasks on them.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	These identified systems (tool types) are in general:&lt;/p&gt;
&lt;p&gt;
	&amp;middot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; SVN&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; :Mercurial&lt;/p&gt;
&lt;p&gt;
	&amp;middot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; WIKI&amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; :Confluence&lt;/p&gt;
&lt;p&gt;
	&amp;middot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; BUG&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; :&amp;nbsp; JIRA Bug - tracking&lt;/p&gt;
&lt;p&gt;
	&amp;middot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; IRC &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; :&amp;nbsp; Communications&lt;/p&gt;
&lt;p&gt;
	&amp;middot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; EMAIL &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; :&amp;nbsp; Communications&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	The information about the systems used is gathered through the provided information from the customer.&lt;/p&gt;
&lt;p&gt;
	For the systems used by the customer, we introduce the name tool type. Because the list above lists all tools the customer use for his development process, and these tools are also the basis data stores, from where the Data Collector gathers its raw data&amp;rsquo;s.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	The Data collector Layer can have two different options to store his extracted Data. The extracted data are the data gathered from the different systems mentioned above. The extracted data from every systems will be transformed in a format which gives only the information&amp;rsquo;s needed and this data will be then stored for further processing through the SNA component. The differences between this option&amp;rsquo;s and the option used and why is explained in the section below.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
</ontowiki_WikiPage:content>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#8_logical_and_implementation_view_-_architecture_background_-_rationale_-_databases_and_data_gathering -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;8_logical_and_implementation_view_-_architecture_background_-_rationale_-_databases_and_data_gathering">
        <rdf:type rdf:resource="&UvA-SA-ontology;WikiPage"/>
        <rdfs:label>8 logical and implementation view - architecture background - rationale - databases and data gathering</rdfs:label>
        <ontowiki_WikiPage:content>&lt;h4&gt;
	1.5.1.2 Databases or Flat file Data stores:&lt;/h4&gt;
&lt;p&gt;
	The data collector needs to temporary stores his extracted data, to provide them to the SNA component. The data collector can accomplish that in two ways, store them in a database or in separate flat file formats, like xml, CSV or an own simple data structure.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	The data store used for the extracted and transformed data from the source systems will be stored in a database system with several database schemas per tool type (Source system type). The elaboration and explained conclusion with the decision is stated in the appendix under section: Appendix Database Flat Files&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	The database will have several database schemas for every used tool type, which represents a source system. This has an impact on the architecture, because so every data gatherer, which is used to gather the data from one type of source system, has its own database parser with own connection and user credentials. An more explained and elaboration and explained conclusion to that decision is stated in the appendix under section: Appendix Database Flat&lt;/p&gt;
&lt;h4&gt;
	1.5.1.3Data gathering Scenario&lt;/h4&gt;
&lt;p&gt;
	To imagine a simple Data collection scenario, here the data gathering process from a SVN repository, we provide one Scenario to collect data from a Data Source. This helps to imagine what an adaptor needs for components to perform its tasks.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	In the scenario above you can see, what for possibilities we have to extract an SVN Log for a Repository. Several Clients updates a repository, as you can see in the customer description, it can happen that several teams work in one repository or a team works on an isolated repository for itself. Every Repository has an associated Log in the SVN server. So there came two main options to get the data from the Log. These options are also applicable on the other systems where data needs to be gathered from. These two options are based on the push &amp;amp; pull conclusion.&lt;/p&gt;
&lt;br clear=&quot;all&quot; /&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	Resulting types of gathering scenario are identified:&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;The two gathering options:&lt;/strong&gt;&lt;/p&gt;
&lt;table border=&quot;1&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot;&gt;
	&lt;tbody&gt;
		&lt;tr&gt;
			&lt;td style=&quot;width:26px;&quot;&gt;
				&lt;p&gt;
					&amp;nbsp;&lt;/p&gt;
			&lt;/td&gt;
			&lt;td style=&quot;width:274px;&quot;&gt;
				&lt;p&gt;
					&lt;strong&gt;Options&lt;/strong&gt;&lt;/p&gt;
			&lt;/td&gt;
			&lt;td style=&quot;width:262px;&quot;&gt;
				&lt;p&gt;
					&lt;strong&gt;Generalized options&lt;/strong&gt;&lt;/p&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;width:26px;&quot;&gt;
				&lt;p&gt;
					&lt;strong&gt;1&lt;/strong&gt;&lt;/p&gt;
			&lt;/td&gt;
			&lt;td style=&quot;width:274px;&quot;&gt;
				&lt;p&gt;
					Periodic listening, on changes for example in the SVN case listening for a commit.&lt;/p&gt;
			&lt;/td&gt;
			&lt;td style=&quot;width:262px;&quot;&gt;
				&lt;p&gt;
					A Listening component needs an extra module in the target systems.&lt;/p&gt;
				&lt;p&gt;
					For further use we call it, &lt;strong&gt;periodic listening.&lt;/strong&gt;&lt;/p&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;width:26px;&quot;&gt;
				&lt;p&gt;
					&lt;strong&gt;2&lt;/strong&gt;&lt;/p&gt;
			&lt;/td&gt;
			&lt;td style=&quot;width:274px;&quot;&gt;
				&lt;p&gt;
					Using different libraries, API&amp;rsquo;S or connector per tool type. This will be also periodically.&lt;/p&gt;
			&lt;/td&gt;
			&lt;td style=&quot;width:262px;&quot;&gt;
				&lt;p&gt;
					Database connection, SOA interface to gather the data directly from the database, or a SVN library to gather the SVN stats.For further use we call it, &lt;strong&gt;periodic queries.&lt;/strong&gt;&lt;/p&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	The two options have in several ways an impact of the architecture, one is that option one gives only hardcoded access to the source systems, where option two gives with the use of standardised and well proved libraries access to the databases or source systems to gather the information. A set of connectors can be configured and provided to separate this part and bring also more extensibility and flexibility, with a low price. So the data gatherer gets its own connection library which defines the access to the system, for example a simulated SVN client or a direct connection to the source database. These methods are lightweight and use given infrastructures. For further details about this decision, please have a look in the appendix under section: Data gathering options&lt;/p&gt;
</ontowiki_WikiPage:content>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#9_logical_and_implementation_view_-_background_-_rationale_-_extensibility_and_business_layer -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;9_logical_and_implementation_view_-_background_-_rationale_-_extensibility_and_business_layer">
        <rdf:type rdf:resource="&UvA-SA-ontology;WikiPage"/>
        <rdfs:label>9 logical and implementation view - background - rationale - extensibility and business layer</rdfs:label>
        <ontowiki_WikiPage:content>&lt;h4&gt;
	1.5.1.4Extensibility of data sources&lt;/h4&gt;
&lt;p&gt;
	By request of the stakeholders, the data sources of the application need to be extensible.&lt;/p&gt;
&lt;p&gt;
	For this, we have determined three scenarios that we named &lt;em&gt;current fit&lt;/em&gt;, &lt;em&gt;partly extensible&lt;/em&gt; and &lt;em&gt;fully extensible&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&amp;middot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;em&gt;current fit &amp;ndash; Fitted on the current source systems, without chance of flexibility&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;
	&amp;middot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;em&gt;partly extensible &amp;ndash; Fitted on the current situation, but with a flexibility to use systems with the same ways to process and retrieve the data.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;
	&amp;middot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;em&gt;fully extensible &amp;ndash; Fully extensible and flexible to use every kind of source system&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	Based on the considerations documented in the &lt;em&gt;considerations &lt;/em&gt;paragraph in the appendix under section &amp;ldquo;Extensibility&amp;rdquo;, and the profile of the stakeholders, the first scenario (current fit) can immediately be marked as not viable. The history and wishes of the stakeholders requires extensibility what the current fit can&amp;rsquo;t provide.&lt;/p&gt;
&lt;p&gt;
	After we compared the second and third scenarios, we have made the decision to go for the &lt;em&gt;partly extensible&lt;/em&gt;-solution. It is hard to predict what kind of new systems will have to be connected in the future. Also when we go for a fully extensible solution, the complexity and with that the development time and &amp;ndash;costs rise. If we look at the profile of the stakeholders,&lt;/p&gt;
&lt;p&gt;
	this complexity is not necessary for their situation. The partly extensible-solution is the best fit for the case of the stakeholders.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	One of the main concerns of the stakeholders was that they like to experiment with different tools. At the moment they might use a specific tool, but if another, better tool arises, there is a large probability that they are going to experiment with it. One of the design decisions was that the architecture will support switching to another tool of a known type. An example is given in the appendix under section: Data gatherer Extensibility&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;Business layer&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	Secondly, the business layer. This is the core of the application; after all data has been abstracted to a certain type of data (version control system data, bug tracking issue data, etc.) the data still needs to be coupled and conclusions must be drawn from it.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	This meant that globally a system or multiple systems would have to be responsible for the following tasks:&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	-&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Receiving data to process from the data layer or pulling it from an external source&lt;/p&gt;
&lt;p&gt;
	-&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Storing data coupling rules (i.e.: if a developer commits to a certain project more than 50 times, he is an expert on the matter)&lt;/p&gt;
&lt;p&gt;
	-&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Coupling the data and persisting it to a data source or passing it through to a representation layer&lt;/p&gt;
</ontowiki_WikiPage:content>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#9_logical_and_implementation_view_-_background_-_rationale_-_receiving_pulling_data -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;9_logical_and_implementation_view_-_background_-_rationale_-_receiving_pulling_data">
        <rdf:type rdf:resource="&UvA-SA-ontology;WikiPage"/>
        <rdfs:label>10 logical and implementation view - background - rationale - receiving pulling data</rdfs:label>
        <ontowiki_WikiPage:content>&lt;p&gt;
	&lt;strong&gt;Receiving/pulling data to process&lt;br /&gt;
	&lt;br /&gt;
	&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
	The application consists of three layers, in which the first and second layer mutate the data delivered to them in order to pass it along to the second layer and the third layer exposes this data to the outside world (if authenticated).&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	Thus a method must be chosen to get data from one layer to another. This can roughly be done in two ways: push or pull.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;Push data &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	The first solution we had considered was pushing data from one layer to another when ready up to the data storage at the end. If performed very puristicly, the data extractors wouldn&amp;rsquo;t so much be extractors but API&amp;rsquo;s that are able to receive data from the appropriate sources.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	This puristic approach immediately poses problems; though some systems support operations after finishing their usual tasks (version control, creation of a bug tracking issue, etc.) not all do. This would mean that not all applications can be integrated into the system.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	If we would pick the less puristic approach, it would mean we only push the data that was processed by the transformers in both the data and business layer to the next module in line. Since the module after the business layer is a database, this is a requirement. Which means the only &amp;ldquo;pushing&amp;rdquo; of data would be from the data to the processing layer. A further explained list of advantages and disadvantages is listed in the appendix under section: Push &amp;amp; pull data from databases.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;Pull data from databases&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	Another option is to store the data abstracted by the transformation module in the data layer and the data processed in the business layer in their own databases. The data can in this case periodically be retrieved from the databases and processed. A further explained list of advantages and disadvantages is listed in the appendix under section: Push pull data from database&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	&lt;strong&gt;Conclusion&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
	After weighing the options, it appears that pushing the data only as a single major advantage: the fact that the critical systems can decide when they have sufficient resources available for pushing their code to the application.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	The biggest disadvantage however, the fact that not all systems are compatible with this solution is reason enough to discard the idea. The stakeholders have said that they&amp;rsquo;re always looking for new tools that can do a better job. If an application turns out to be incompatible with this system, not all necessary data can be used to draw conclusions regarding communication, etc. This should not be allowed to happen.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
&lt;p&gt;
	Though non-trivial, it is possible to use monitoring software to measure when to pull data from an external source. Since the problem can be overcome this way, there is really no argument left why not to choose for a pull-strategy.&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;&lt;/p&gt;
</ontowiki_WikiPage:content>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Analsyis_data_in_graph_database -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Analsyis_data_in_graph_database">
        <rdf:type rdf:resource="&UvA-SA-ontology;Design_Alternatives"/>
        <rdfs:label>Analsyis data in graph database</rdfs:label>
        <status>Accepted</status>
        <UvA-SA-ontology:arguments>Advantages: Performance gains when querying relationships between nodes.  + adoption by large companties

Disadvantages: the technology has not been around for quite as long + storage costs</UvA-SA-ontology:arguments>
        <UvA-SA-ontology:name>Analsyis data in graph database</UvA-SA-ontology:name>
        <UvA-SA-ontology:posit_design rdf:resource="&Ontology1308582601209;Analsyis_database_is_relational"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Analsyis_database_is_relational -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Analsyis_database_is_relational">
        <rdf:type rdf:resource="&UvA-SA-ontology;Design_Alternatives"/>
        <rdfs:label>Analsyis data in relational database</rdfs:label>
        <status>Rejected</status>
        <UvA-SA-ontology:arguments>Advantages: Lots of mature commercial as well as open-source implementations exist. High quality tooling exists + Most developers have at least a basic understanding of SQL and there is plenty of information to find on the subject online.

Disadvantages: High cost, low performance : data is divided into several tables, which sometimes have to be joined together. This takes a lot of time if the data size grows larger.</UvA-SA-ontology:arguments>
        <UvA-SA-ontology:name>Analsyis data in relational database</UvA-SA-ontology:name>
        <UvA-SA-ontology:posit_design rdf:resource="&Ontology1308582601209;Analsyis_data_in_graph_database"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Analysis_database -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Analysis_database">
        <rdf:type rdf:resource="&UvA-SA-ontology;Data_store"/>
        <rdfs:label>Analysis database</rdfs:label>
        <UvA-SA-ontology:name>Analysis database</UvA-SA-ontology:name>
        <UvA-SA-ontology:is_modeled_in rdf:resource="&UvA-SA-ontology;component_model"/>
        <UvA-SA-ontology:satisfies rdf:resource="&Ontology1308582601209;Cost"/>
        <UvA-SA-ontology:satisfies rdf:resource="&Ontology1308582601209;Performance"/>
        <UvA-SA-ontology:satisfies rdf:resource="&Ontology1308582601209;Storage_of_analysis_data"/>
        <realizes rdf:resource="&Ontology1308582601209;Transforming_data"/>
        <UvA-SA-ontology:part_of rdf:resource="&Ontology1308582601209;data_access_layer_(analysis)"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Analysis_database_type -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Analysis_database_type">
        <rdf:type rdf:resource="&Ontology1308582601209;Design_issue"/>
        <rdfs:label>Analysis database type</rdfs:label>
        <UvA-SA-ontology:name>Analysis database type</UvA-SA-ontology:name>
        <UvA-SA-ontology:design_decision>We conclude that the graph database is the best fit for this problem, provided that the developers  that will ultimately create this application study the ins and outs of it thoroughly. The performance  gain and the fact that large companies to achieve similar goals use this sort of database system provide us enough confidence to recommend this solution.</UvA-SA-ontology:design_decision>
        <status>Decided</status>
        <UvA-SA-ontology:decision_issue>After coupling the data and drawing some conclusions from it, the data needs to be stored in some sort of database. </UvA-SA-ontology:decision_issue>
        <UvA-SA-ontology:posit_design rdf:resource="&Ontology1308582601209;Analsyis_data_in_graph_database"/>
        <UvA-SA-ontology:posit_design rdf:resource="&Ontology1308582601209;Analsyis_database_is_relational"/>
        <UvA-SA-ontology:decision_is_about rdf:resource="&Ontology1308582601209;Analysis_database"/>
        <UvA-SA-ontology:depends_on rdf:resource="&Ontology1308582601209;Cost"/>
        <UvA-SA-ontology:depends_on rdf:resource="&Ontology1308582601209;Performance"/>
        <UvA-SA-ontology:depends_on rdf:resource="&Ontology1308582601209;Storage_of_analysis_data"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Application_server -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Application_server">
        <rdf:type rdf:resource="&UvA-SA-ontology;Server"/>
        <rdfs:label>Application server</rdfs:label>
        <UvA-SA-ontology:name>Application server</UvA-SA-ontology:name>
        <UvA-SA-ontology:description>The application server contains all the layers  of the SNA system and includes a web server (API) where clients connect to</UvA-SA-ontology:description>
        <UvA-SA-ontology:hosts rdf:resource="&UvA-SA-ontology;Business_Logic_Layer"/>
        <UvA-SA-ontology:hosts rdf:resource="&UvA-SA-ontology;Representation_Layer"/>
        <UvA-SA-ontology:hosts rdf:resource="&UvA-SA-ontology;data_layer"/>
        <UvA-SA-ontology:satisfies rdf:resource="&Ontology1308582601209;Conformance_to_existing_security_regulations"/>
        <UvA-SA-ontology:is_modeled_in rdf:resource="&Ontology1308582601209;Deployment_diagram_-_Primary_presentation"/>
        <UvA-SA-ontology:presented_in rdf:resource="&Ontology1308582601209;Deployment_view"/>
        <UvA-SA-ontology:is_modeled_in rdf:resource="&Ontology1308582601209;Infrastructure_context_diagram"/>
        <UvA-SA-ontology:satisfies rdf:resource="&Ontology1308582601209;Minimum_amount_of_configuration"/>
        <UvA-SA-ontology:satisfies rdf:resource="&Ontology1308582601209;No_changes_to_existing_infrastructure"/>
        <UvA-SA-ontology:satisfies rdf:resource="&Ontology1308582601209;Security"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Architect -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Architect">
        <rdf:type rdf:resource="&UvA-SA-ontology;Stakeholder"/>
        <rdfs:label>Architect</rdfs:label>
        <UvA-SA-ontology:name>Architect</UvA-SA-ontology:name>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Availability -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Availability">
        <rdf:type rdf:resource="&UvA-SA-ontology;Non_functional_requirement"/>
        <rdf:type rdf:resource="&Ontology1308582601209;Concern"/>
        <rdfs:label>Availability</rdfs:label>
        <UvA-SA-ontology:name>Availability</UvA-SA-ontology:name>
        <UvA-SA-ontology:description>Availability  is not a major concern of the stakeholders, but it still reduces the amount of work that is needed which is something pointing out.</UvA-SA-ontology:description>
        <UvA-SA-ontology:realized_by rdf:resource="&Ontology1308582601209;Business_rules_engine"/>
        <UvA-SA-ontology:is_concern_of rdf:resource="&Ontology1308582601209;Previous"/>
        <addressed_by rdf:resource="&Ontology1308582601209;two_separated_servers"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Bugtracking_tools -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Bugtracking_tools">
        <rdf:type rdf:resource="&UvA-SA-ontology;Data_store"/>
        <rdf:type rdf:resource="&UvA-SA-ontology;Tool"/>
        <rdfs:label>Bugtracking tools</rdfs:label>
        <UvA-SA-ontology:description>A bug tracking tool is used to keep track of bugs found in a system or code file. Using a bug tracker, a development team can keep track of the files that cause the most problems and which bugs are repeating in occurrence. Therefore, it will become easier for the team to fix these bugs in the future.

A Bug is a complication within a software system that causes unwanted or unexpected system behaviour.

An example of Bugtracking tools is: Bugzilla</UvA-SA-ontology:description>
        <UvA-SA-ontology:name>Bugtracking tools</UvA-SA-ontology:name>
        <UvA-SA-ontology:is_modeled_in rdf:resource="&Ontology1308582601209;Context_diagram"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Business_rules_engine -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Business_rules_engine">
        <rdf:type rdf:resource="&UvA-SA-ontology;Component"/>
        <rdfs:label>Business rules engine</rdfs:label>
        <UvA-SA-ontology:name>Business rules engine</UvA-SA-ontology:name>
        <UvA-SA-ontology:description>The business rule engine contains a set of business rules that are used for decision making and derivation of information from the data in the relational database. These rules can be set by the users via the configurations module. These business rules can contain for example: &lt;If a user has committed more than 10 .java files, user is an expert on Java&gt;. These business rules will influence the transformer and extractor components, as the extractor must derive from the business rules which data fields to extract from the relational database, while the transformer must transform this data accordingly.</UvA-SA-ontology:description>
        <UvA-SA-ontology:part_of rdf:resource="&UvA-SA-ontology;Business_Logic_Layer"/>
        <UvA-SA-ontology:is_modeled_in rdf:resource="&UvA-SA-ontology;component_model"/>
        <UvA-SA-ontology:satisfies rdf:resource="&Ontology1308582601209;Availability"/>
        <UvA-SA-ontology:satisfies rdf:resource="&Ontology1308582601209;Complexity"/>
        <UvA-SA-ontology:is_modeled_in rdf:resource="&Ontology1308582601209;Deployment_diagram_-_Primary_presentation"/>
        <UvA-SA-ontology:satisfies rdf:resource="&Ontology1308582601209;Flexibility"/>
        <UvA-SA-ontology:satisfies rdf:resource="&Ontology1308582601209;Maintainability"/>
        <realizes rdf:resource="&Ontology1308582601209;Modify_business_rules"/>
        <UvA-SA-ontology:satisfies rdf:resource="&Ontology1308582601209;Provide_Application_Programming_Interface_(API)"/>
        <realizes rdf:resource="&Ontology1308582601209;Transforming_data"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Centralized_data_scheme -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Centralized_data_scheme">
        <rdf:type rdf:resource="&UvA-SA-ontology;Design_Alternatives"/>
        <rdfs:label>Centralized data schema for tool types</rdfs:label>
        <UvA-SA-ontology:description>On way to store the extracted data from the different data sources (tool types) is to store the data in one global database schema, with tables for every tool type, for example a table for the transformed SVN data from the SVN gatherer.</UvA-SA-ontology:description>
        <status>Rejected</status>
        <UvA-SA-ontology:name>Centralized data schema for tool types</UvA-SA-ontology:name>
        <UvA-SA-ontology:arguments>Advantage: It is simple to administrate. Not a lot of server performance used compared with the decentralized version.

Disadvantages: Can form a bottleneck if too many operations are executed on the schema.</UvA-SA-ontology:arguments>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Choose_representation -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Choose_representation">
        <rdf:type rdf:resource="&UvA-SA-ontology;Functional_requirement"/>
        <rdfs:label>Choose representation</rdfs:label>
        <UvA-SA-ontology:name>Choose representation</UvA-SA-ontology:name>
        <UvA-SA-ontology:description>Previous needs to be free to choose whichever representation they’d like </UvA-SA-ontology:description>
        <UvA-SA-ontology:realized_by rdf:resource="&Ontology1308582601209;representation_API_"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Client_server_pattern -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Client_server_pattern">
        <rdf:type rdf:resource="&Ontology1308582601209;Pattern"/>
        <rdfs:label>Client-server pattern</rdfs:label>
        <UvA-SA-ontology:description>The SNA system is distributed on two servers which are connected on the same network. Therefore all workstations have access to the SNA system too.</UvA-SA-ontology:description>
        <UvA-SA-ontology:name>Client-server pattern</UvA-SA-ontology:name>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Communication_tools_ -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Communication_tools_">
        <rdf:type rdf:resource="&UvA-SA-ontology;Data_store"/>
        <rdf:type rdf:resource="&UvA-SA-ontology;Tool"/>
        <rdfs:label>Communication tools</rdfs:label>
        <UvA-SA-ontology:name>Communication tools</UvA-SA-ontology:name>
        <UvA-SA-ontology:description>Tools used to facilitate documentation. For example: Outlook (for e-mail), Lync or IRC (For instant messaging)

Examples of communication tools are: Mail, IRC</UvA-SA-ontology:description>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Compatability -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Compatability">
        <rdf:type rdf:resource="&UvA-SA-ontology;Non_functional_requirement"/>
        <rdfs:label>Compatability</rdfs:label>
        <UvA-SA-ontology:name>Compatability</UvA-SA-ontology:name>
        <UvA-SA-ontology:related_to rdf:resource="&Ontology1308582601209;Extensibility_of_data_sources"/>
        <UvA-SA-ontology:related_to rdf:resource="&Ontology1308582601209;Provide_Application_Programming_Interface_(API)"/>
        <UvA-SA-ontology:related_to rdf:resource="&Ontology1308582601209;Transformation_of_gathered_data"/>
        <addressed_by rdf:resource="&Ontology1308582601209;data_extraction_technique_-_push_or_pull"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Complexity -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Complexity">
        <rdf:type rdf:resource="&UvA-SA-ontology;Non_functional_requirement"/>
        <rdfs:label>Complexity</rdfs:label>
        <UvA-SA-ontology:name>complexity</UvA-SA-ontology:name>
        <UvA-SA-ontology:realized_by rdf:resource="&Ontology1308582601209;Business_rules_engine"/>
        <UvA-SA-ontology:results_in rdf:resource="&Ontology1308582601209;Business_rules_engine"/>
        <UvA-SA-ontology:related_to rdf:resource="&Ontology1308582601209;Development_time"/>
        <UvA-SA-ontology:related_to rdf:resource="&Ontology1308582601209;Modifiability"/>
        <addressed_by rdf:resource="&Ontology1308582601209;Rule_handling_for_processing_data"/>
        <UvA-SA-ontology:related_to rdf:resource="&Ontology1308582601209;Transformation_of_gathered_data"/>
        <addressed_by rdf:resource="&Ontology1308582601209;data_sources_of_application_need_to_be_extensible"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Configuration_Module -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Configuration_Module">
        <rdf:type rdf:resource="&UvA-SA-ontology;Component"/>
        <rdfs:label>Configuration Module</rdfs:label>
        <UvA-SA-ontology:description>The configuration module is a module for users to give their input on the conversion of data. As architect it’s hard to determine which queries are necessary for the system to be useful. Next to that, it’s also hard to determine how often these queries will change. Therefore, we decided to create a module where users can decide which data gets converted into which format and which significance each piece of data gets. This way, the user is in full control over their data.</UvA-SA-ontology:description>
        <UvA-SA-ontology:name>Configuration Module</UvA-SA-ontology:name>
        <UvA-SA-ontology:part_of rdf:resource="&UvA-SA-ontology;Business_Logic_Layer"/>
        <UvA-SA-ontology:is_modeled_in rdf:resource="&UvA-SA-ontology;component_model"/>
        <realizes rdf:resource="&Ontology1308582601209;Modify_business_rules"/>
        <UvA-SA-ontology:satisfies rdf:resource="&Ontology1308582601209;Transformation_of_gathered_data"/>
        <UvA-SA-ontology:communicates_with rdf:resource="&Ontology1308582601209;user"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Conformance_to_existing_security_regulations -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Conformance_to_existing_security_regulations">
        <rdf:type rdf:resource="&UvA-SA-ontology;Non_functional_requirement"/>
        <rdf:type rdf:resource="&Ontology1308582601209;Concern"/>
        <rdfs:label>Conformance to existing security regulations</rdfs:label>
        <UvA-SA-ontology:name>Conformance to existing security regulations</UvA-SA-ontology:name>
        <UvA-SA-ontology:realized_by rdf:resource="&Ontology1308582601209;Application_server"/>
        <UvA-SA-ontology:realized_by rdf:resource="&Ontology1308582601209;Database_server"/>
        <UvA-SA-ontology:is_concern_of rdf:resource="&Ontology1308582601209;Previous"/>
        <UvA-SA-ontology:related_to rdf:resource="&Ontology1308582601209;Security"/>
        <UvA-SA-ontology:realized_by rdf:resource="&Ontology1308582601209;representation_API_"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Context_diagram -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Context_diagram">
        <rdf:type rdf:resource="&UvA-SA-ontology;Diagram"/>
        <rdfs:label>Context diagram - software systems</rdfs:label>
        <UvA-SA-ontology:name>Context diagram - software systems</UvA-SA-ontology:name>
        <UvA-SA-ontology:models rdf:resource="&UvA-SA-ontology;Business_Logic_Layer"/>
        <UvA-SA-ontology:models rdf:resource="&UvA-SA-ontology;Representation_Layer"/>
        <UvA-SA-ontology:models rdf:resource="&UvA-SA-ontology;data_layer"/>
        <UvA-SA-ontology:models rdf:resource="&Ontology1308582601209;Bugtracking_tools"/>
        <UvA-SA-ontology:models rdf:resource="&Ontology1308582601209;Communication_tools_"/>
        <UvA-SA-ontology:models rdf:resource="&Ontology1308582601209;Project_management_tools"/>
        <UvA-SA-ontology:models rdf:resource="&Ontology1308582601209;Versioning_tools_"/>
        <UvA-SA-ontology:models rdf:resource="&Ontology1308582601209;data_access_layer_(analysis)"/>
        <UvA-SA-ontology:models rdf:resource="&Ontology1308582601209;data_access_layer_(relational)"/>
        <UvA-SA-ontology:models rdf:resource="&Ontology1308582601209;user"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Cost -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Cost">
        <rdf:type rdf:resource="&UvA-SA-ontology;Non_functional_requirement"/>
        <rdfs:label>Cost</rdfs:label>
        <UvA-SA-ontology:name>Cost</UvA-SA-ontology:name>
        <UvA-SA-ontology:realized_by rdf:resource="&Ontology1308582601209;Analysis_database"/>
        <addressed_by rdf:resource="&Ontology1308582601209;Analysis_database_type"/>
        <UvA-SA-ontology:related_to rdf:resource="&Ontology1308582601209;Development_time"/>
        <addressed_by rdf:resource="&Ontology1308582601209;Method_of_data_gathering"/>
        <UvA-SA-ontology:realized_by rdf:resource="&Ontology1308582601209;Scheduler"/>
        <UvA-SA-ontology:results_in rdf:resource="&Ontology1308582601209;Scheduler"/>
        <addressed_by rdf:resource="&Ontology1308582601209;Storage_of_extracted_data"/>
        <addressed_by rdf:resource="&Ontology1308582601209;data_sources_of_application_need_to_be_extensible"/>
        <UvA-SA-ontology:results_in rdf:resource="&Ontology1308582601209;relational_database"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Creation_and_use_of_extractor_and_transformer -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Creation_and_use_of_extractor_and_transformer">
        <rdf:type rdf:resource="&UvA-SA-ontology;Diagram"/>
        <rdfs:label>Creation and use of extractor and transformer</rdfs:label>
        <UvA-SA-ontology:name>Creation and use of extractor and transformer</UvA-SA-ontology:name>
        <UvA-SA-ontology:supports rdf:resource="&Ontology1308582601209;Data_gatherer_extensibility"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Criticality_of_existing_tools -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Criticality_of_existing_tools">
        <rdf:type rdf:resource="&UvA-SA-ontology;Non_functional_requirement"/>
        <rdf:type rdf:resource="&Ontology1308582601209;Concern"/>
        <rdfs:label>Criticality of existing tools</rdfs:label>
        <UvA-SA-ontology:description>The stakeholders have reported that existing support tools and systems are critical and must in no way be harmed (i.e. by recourse consumption from the &#39;SNA - facebook for developers&#39; system.)
Our system must therefore interfere as little as possible with the current (process-critical) tools.  </UvA-SA-ontology:description>
        <UvA-SA-ontology:name>Criticality of existing tools</UvA-SA-ontology:name>
        <UvA-SA-ontology:realized_by rdf:resource="&Ontology1308582601209;Extractor"/>
        <addressed_by rdf:resource="&Ontology1308582601209;Method_of_data_gathering"/>
        <UvA-SA-ontology:related_to rdf:resource="&Ontology1308582601209;Performance"/>
        <UvA-SA-ontology:is_concern_of rdf:resource="&Ontology1308582601209;Previous"/>
        <UvA-SA-ontology:related_to rdf:resource="&Ontology1308582601209;Provide_Application_Programming_Interface_(API)"/>
        <UvA-SA-ontology:realized_by rdf:resource="&Ontology1308582601209;Scheduler"/>
        <UvA-SA-ontology:results_in rdf:resource="&Ontology1308582601209;Scheduler"/>
        <addressed_by rdf:resource="&Ontology1308582601209;data_extraction_technique_-_push_or_pull"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Current_fit_data_sources -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Current_fit_data_sources">
        <rdf:type rdf:resource="&UvA-SA-ontology;Design_Alternatives"/>
        <rdf:type rdf:resource="&UvA-SA-ontology;Scenario"/>
        <rdfs:label>Current fit data sources</rdfs:label>
        <UvA-SA-ontology:arguments>This solution isn’t extensible, because it is fitted to the current infrastructure of the organization. When a new data source is introduced, it has to be fitted to the application as well.

The current fit-solution is not complex , relative to the other solutions, because there aren’t any abstractions. The implementations are tightly coupled in the system which makes the application pretty simple.

If we look at the first solution, we see that it is easy to deploy . Only the initial configuration is needed to fit it to the systems within the organization, and no other configuration is needed.</UvA-SA-ontology:arguments>
        <UvA-SA-ontology:name>Current fit data sources</UvA-SA-ontology:name>
        <UvA-SA-ontology:description>This scenario describes a current fit – Fitted on the current source systems, without chance of flexibility.

Within this scenario, the application is fitted to the current system. This means that the application is tightly coupled to the current infrastructure of the organization. 
For instance, the organization currently uses Mercurial for version control . In this scenario the application is tightly fitted to this version control system. If a new version control system is going to be used by the organization, the internal structure of the application needs to be modified .
</UvA-SA-ontology:description>
        <status>Rejected</status>
        <UvA-SA-ontology:supported_by rdf:resource="&Ontology1308582601209;Current_fit_data_sources"/>
        <UvA-SA-ontology:supported_by rdf:resource="&Ontology1308582601209;Data_gathering"/>
        <UvA-SA-ontology:based_on rdf:resource="&Ontology1308582601209;tools_will_more_frequently_change_than_tool_types."/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Data_conversion_by_users -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Data_conversion_by_users">
        <rdf:type rdf:resource="&Ontology1308582601209;Design_issue"/>
        <rdfs:label>Data conversion by users</rdfs:label>
        <UvA-SA-ontology:description>we decided to create a module where users can decide which data gets converted into which format and which significance each piece of data gets. This way, the user is in full control over their data.</UvA-SA-ontology:description>
        <UvA-SA-ontology:name>Data conversion by users</UvA-SA-ontology:name>
        <status>decided</status>
        <UvA-SA-ontology:results_in rdf:resource="&Ontology1308582601209;Configuration_Module"/>
        <UvA-SA-ontology:depends_on rdf:resource="&Ontology1308582601209;Transformation_of_gathered_data"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Data_gatherer_extensibility -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Data_gatherer_extensibility">
        <rdf:type rdf:resource="&UvA-SA-ontology;Scenario"/>
        <rdfs:label>Data gatherer extensibility scenario</rdfs:label>
        <UvA-SA-ontology:description>an example has been laid out, which shows how the application could react to such a change. The example focuses on version control systems, but the general idea is applicable for all types.
It should be noted that this is just an example to show extensibility and not a definite design of the application
</UvA-SA-ontology:description>
        <UvA-SA-ontology:name>Data gatherer extensibility scenario</UvA-SA-ontology:name>
        <UvA-SA-ontology:supported_by rdf:resource="&Ontology1308582601209;Creation_and_use_of_extractor_and_transformer"/>
        <UvA-SA-ontology:depends_on rdf:resource="&Ontology1308582601209;Extensibility_of_data_sources"/>
        <UvA-SA-ontology:depends_on rdf:resource="&Ontology1308582601209;Flexibility"/>
        <UvA-SA-ontology:is_modeled_in rdf:resource="&Ontology1308582601209;Implementation_for_Mercurial"/>
        <UvA-SA-ontology:is_modeled_in rdf:resource="&Ontology1308582601209;Interfaces_for_extracting_and_transforming_data_"/>
        <UvA-SA-ontology:is_modeled_in rdf:resource="&Ontology1308582601209;Internal_representation_of_a_commit"/>
        <UvA-SA-ontology:supports rdf:resource="&Ontology1308582601209;Periodic_listening_for_data_gathering"/>
        <UvA-SA-ontology:supports rdf:resource="&Ontology1308582601209;Periodic_queries_for_data_gathering"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Data_gathering -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Data_gathering">
        <rdf:type rdf:resource="&UvA-SA-ontology;Scenario"/>
        <rdfs:label>Data gathering</rdfs:label>
        <UvA-SA-ontology:description>To imagine a simple Data collection scenario, here the data gathering process from a SVN repository, we provide one Scenario to collect data from a Data Source. This helps to imagine what an adaptor needs for components to perform its tasks.</UvA-SA-ontology:description>
        <UvA-SA-ontology:name>Data gathering</UvA-SA-ontology:name>
        <UvA-SA-ontology:supports rdf:resource="&Ontology1308582601209;Current_fit_data_sources"/>
        <UvA-SA-ontology:is_modeled_in rdf:resource="&Ontology1308582601209;Dollect_data"/>
        <UvA-SA-ontology:supports rdf:resource="&Ontology1308582601209;Partly_extensible_data_sources"/>
        <UvA-SA-ontology:supports rdf:resource="&Ontology1308582601209;Periodic_listening_for_data_gathering"/>
        <UvA-SA-ontology:supports rdf:resource="&Ontology1308582601209;Periodic_queries_for_data_gathering"/>
        <UvA-SA-ontology:supports rdf:resource="&Ontology1308582601209;fully_extensible_data_sources"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Data_integrity -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Data_integrity">
        <rdf:type rdf:resource="&UvA-SA-ontology;Non_functional_requirement"/>
        <rdfs:label>Data integrity</rdfs:label>
        <UvA-SA-ontology:name>Data integrity</UvA-SA-ontology:name>
        <addressed_by rdf:resource="&Ontology1308582601209;Storage_of_extracted_data"/>
        <UvA-SA-ontology:related_to rdf:resource="&Ontology1308582601209;Storage_of_extracted_data"/>
        <UvA-SA-ontology:related_to rdf:resource="&Ontology1308582601209;Transformation_of_gathered_data"/>
        <UvA-SA-ontology:results_in rdf:resource="&Ontology1308582601209;relational_database"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Database_server -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Database_server">
        <rdf:type rdf:resource="&UvA-SA-ontology;Server"/>
        <rdfs:label>Database server</rdfs:label>
        <UvA-SA-ontology:name>Database server</UvA-SA-ontology:name>
        <UvA-SA-ontology:description>The application server  connects to the database server for storage and retrieval of intermediate results of the tool extraction and analysis. The database server hosts two different databases</UvA-SA-ontology:description>
        <UvA-SA-ontology:satisfies rdf:resource="&Ontology1308582601209;Conformance_to_existing_security_regulations"/>
        <UvA-SA-ontology:is_modeled_in rdf:resource="&Ontology1308582601209;Deployment_diagram_-_Primary_presentation"/>
        <UvA-SA-ontology:presented_in rdf:resource="&Ontology1308582601209;Deployment_view"/>
        <UvA-SA-ontology:is_modeled_in rdf:resource="&Ontology1308582601209;Infrastructure_context_diagram"/>
        <UvA-SA-ontology:satisfies rdf:resource="&Ontology1308582601209;Minimum_amount_of_configuration"/>
        <UvA-SA-ontology:satisfies rdf:resource="&Ontology1308582601209;No_changes_to_existing_infrastructure"/>
        <UvA-SA-ontology:satisfies rdf:resource="&Ontology1308582601209;Security"/>
        <UvA-SA-ontology:hosts rdf:resource="&Ontology1308582601209;data_access_layer_(analysis)"/>
        <UvA-SA-ontology:hosts rdf:resource="&Ontology1308582601209;data_access_layer_(relational)"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Decentralized_data_scheme -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Decentralized_data_scheme">
        <rdf:type rdf:resource="&UvA-SA-ontology;Design_Alternatives"/>
        <rdfs:label>Decentralized data schema for tool types</rdfs:label>
        <UvA-SA-ontology:name>Decentralized data schema for tool types</UvA-SA-ontology:name>
        <status>Accepted</status>
        <UvA-SA-ontology:arguments>Advantages: Separation of concerns, every type has its own schema.
Better backup strategies possible, per schema for example.
Better extensibility, for example if more load occurs as expected the schemas could easily moved to an extra database server.

Disadvantages: Small overhead for the Database system.
Small overhead for the database administrator.</UvA-SA-ontology:arguments>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Deployment_diagram_-_Primary_presentation -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Deployment_diagram_-_Primary_presentation">
        <rdf:type rdf:resource="&UvA-SA-ontology;Diagram"/>
        <rdfs:label>UML Deployment diagram - Primary presentation</rdfs:label>
        <UvA-SA-ontology:name>UML Deployment diagram - Primary presentation</UvA-SA-ontology:name>
        <UvA-SA-ontology:models rdf:resource="&UvA-SA-ontology;Business_Logic_Layer"/>
        <UvA-SA-ontology:models rdf:resource="&UvA-SA-ontology;Representation_Layer"/>
        <UvA-SA-ontology:models rdf:resource="&UvA-SA-ontology;data_layer"/>
        <UvA-SA-ontology:models rdf:resource="&Ontology1308582601209;Application_server"/>
        <UvA-SA-ontology:models rdf:resource="&Ontology1308582601209;Business_rules_engine"/>
        <UvA-SA-ontology:models rdf:resource="&Ontology1308582601209;Database_server"/>
        <UvA-SA-ontology:models rdf:resource="&Ontology1308582601209;Extractor"/>
        <UvA-SA-ontology:models rdf:resource="&Ontology1308582601209;representation_API_"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Deployment_view -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Deployment_view">
        <rdf:type rdf:resource="&UvA-SA-ontology;View"/>
        <rdfs:label>Deployment view</rdfs:label>
        <UvA-SA-ontology:name>Deployment view</UvA-SA-ontology:name>
        <UvA-SA-ontology:presents rdf:resource="&UvA-SA-ontology;Business_Logic_Layer"/>
        <UvA-SA-ontology:presents rdf:resource="&UvA-SA-ontology;Representation_Layer"/>
        <UvA-SA-ontology:presents rdf:resource="&UvA-SA-ontology;data_layer"/>
        <UvA-SA-ontology:presents rdf:resource="&Ontology1308582601209;Application_server"/>
        <UvA-SA-ontology:presents rdf:resource="&Ontology1308582601209;Database_server"/>
        <UvA-SA-ontology:presents rdf:resource="&Ontology1308582601209;data_access_layer_(analysis)"/>
        <UvA-SA-ontology:presents rdf:resource="&Ontology1308582601209;data_access_layer_(relational)"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Development_time -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Development_time">
        <rdf:type rdf:resource="&UvA-SA-ontology;Non_functional_requirement"/>
        <rdfs:label>Development time</rdfs:label>
        <UvA-SA-ontology:name>Development time</UvA-SA-ontology:name>
        <UvA-SA-ontology:related_to rdf:resource="&Ontology1308582601209;Cost"/>
        <addressed_by rdf:resource="&Ontology1308582601209;data_sources_of_application_need_to_be_extensible"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Distribution_of_data_schema_for_tool_types -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Distribution_of_data_schema_for_tool_types">
        <rdf:type rdf:resource="&Ontology1308582601209;Design_issue"/>
        <rdfs:label>Data schema for tool types</rdfs:label>
        <UvA-SA-ontology:decision_issue>? For the data collector there 2 existing ways to store the extracted data from the different data sources  (tool types)</UvA-SA-ontology:decision_issue>
        <UvA-SA-ontology:arguments>To store the collected raw data in databases per system brings an extra boost in performance  and parallel working abilities. But more it brings extra advantages in the administration  and security  side. It extends the possibility to move the schemas on different servers, if the load is more than expected, or even if one server moves to another. Further it brings separation of concern in the database schemas, so the backups could be planned per tool type and its database. A downside is it asks more administration needs then the one schema solution.</UvA-SA-ontology:arguments>
        <UvA-SA-ontology:design_decision>Decentralized data schema. 
The decision is to use a database schema for every tool type. This decision is based on the conclusion above. The database schema per tool type brings the needed extensibility also on the administration side. It also brings flexibility in moving the schemas or even to delete them when no data Gatherer for this type exists.</UvA-SA-ontology:design_decision>
        <UvA-SA-ontology:name>Data schema for tool types</UvA-SA-ontology:name>
        <status>Decided</status>
        <UvA-SA-ontology:posit_design rdf:resource="&Ontology1308582601209;Centralized_data_scheme"/>
        <UvA-SA-ontology:posit_design rdf:resource="&Ontology1308582601209;Decentralized_data_scheme"/>
        <UvA-SA-ontology:depends_on rdf:resource="&Ontology1308582601209;Extensibility_of_data_sources"/>
        <UvA-SA-ontology:depends_on rdf:resource="&Ontology1308582601209;Extractor"/>
        <UvA-SA-ontology:depends_on rdf:resource="&Ontology1308582601209;Flexibility"/>
        <UvA-SA-ontology:depends_on rdf:resource="&Ontology1308582601209;Performance"/>
        <UvA-SA-ontology:depends_on rdf:resource="&Ontology1308582601209;Security"/>
        <UvA-SA-ontology:decision_is_about rdf:resource="&Ontology1308582601209;relational_database"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Dollect_data -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Dollect_data">
        <rdf:type rdf:resource="&UvA-SA-ontology;Diagram"/>
        <rdfs:label>Collect data</rdfs:label>
        <UvA-SA-ontology:name>Collect data</UvA-SA-ontology:name>
        <UvA-SA-ontology:models rdf:resource="&Ontology1308582601209;Data_gathering"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#ETL_pattern -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;ETL_pattern">
        <rdf:type rdf:resource="&Ontology1308582601209;Pattern"/>
        <rdfs:label>ETL pattern</rdfs:label>
        <UvA-SA-ontology:description>On the level of the data sources, we are using the ETL architectural pattern. ETL stands for Extraction, Transformation and Load.In the extraction step, the external system is queried for data. Thereafter, the extracted data is transformed into a representation used within our system for the specific type. Finally, the transformed data is saved into the data store.</UvA-SA-ontology:description>
        <UvA-SA-ontology:name>ETL pattern</UvA-SA-ontology:name>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Entering_business_rules -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Entering_business_rules">
        <rdf:type rdf:resource="&Ontology1308582601209;Design_issue"/>
        <rdfs:label>Entering business rules</rdfs:label>
        <UvA-SA-ontology:decision_issue>We need to decide on how to enter new business rules</UvA-SA-ontology:decision_issue>
        <UvA-SA-ontology:description>One of the things that we’re not going to decide on right now is how to enter new business rules. This could be in a text file the business rules engine depends on, or in some sort of database. A user interface could be built or we could let developers edit the source directly. We feel this is too much of a detail to focus our attention on in this stage of the application’s development, it should be decided when the systems are being designed at a more fine-grained level. </UvA-SA-ontology:description>
        <UvA-SA-ontology:name>Entering business rules</UvA-SA-ontology:name>
        <status>To be decided</status>
        <UvA-SA-ontology:decision_is_about rdf:resource="&Ontology1308582601209;Business_rules_engine"/>
        <UvA-SA-ontology:decision_is_about rdf:resource="&Ontology1308582601209;developer"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Extensibility_of_data_sources -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Extensibility_of_data_sources">
        <rdf:type rdf:resource="&UvA-SA-ontology;Non_functional_requirement"/>
        <rdf:type rdf:resource="&Ontology1308582601209;Concern"/>
        <rdfs:label>Extensibility of data gathering</rdfs:label>
        <UvA-SA-ontology:name>Extensibility of data gathering</UvA-SA-ontology:name>
        <UvA-SA-ontology:description>By request of the  stakeholders, the data sources of the application need to be extensible. 

One of the main concerns of the stakeholders was that they like to experiment with different tools. At the moment they might use a specific tool, but if another, better tool arises, there is a large probability that they are going to experiment with it. 

The stakeholders indicated that they want to use the latest tools and techniques to use with their projects. If we look at the history of the company of the stakeholders, we see that they indeed switch their tools once in a while. However, they actually switch tools, and don’t add tools which they didn’t use before.
To double check, we asked the stakeholders how they foresee the use of tools in the future. They indeed verified that when they introduce a new tool, it is often to replace existing tools and not to introduce a completely new tool. They also indicated that there currently isn’t a need to introduce a completely new tool into the organization. 
</UvA-SA-ontology:description>
        <addressed_by rdf:resource="&Ontology1308582601209;Distribution_of_data_schema_for_tool_types"/>
        <UvA-SA-ontology:related_to rdf:resource="&Ontology1308582601209;Flexibility"/>
        <UvA-SA-ontology:related_to rdf:resource="&Ontology1308582601209;Maintainability"/>
        <addressed_by rdf:resource="&Ontology1308582601209;Method_of_data_gathering"/>
        <UvA-SA-ontology:is_concern_of rdf:resource="&Ontology1308582601209;Previous"/>
        <UvA-SA-ontology:results_in rdf:resource="&Ontology1308582601209;Scheduler"/>
        <UvA-SA-ontology:realized_by rdf:resource="&Ontology1308582601209;Scheduler"/>
        <addressed_by rdf:resource="&Ontology1308582601209;Support_tool_switch"/>
        <UvA-SA-ontology:related_to rdf:resource="&Ontology1308582601209;Transformation_of_gathered_data"/>
        <addressed_by rdf:resource="&Ontology1308582601209;data_extraction_technique_-_push_or_pull"/>
        <addressed_by rdf:resource="&Ontology1308582601209;data_sources_of_application_need_to_be_extensible"/>
        <UvA-SA-ontology:realized_by rdf:resource="&Ontology1308582601209;relational_database"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Extractor -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Extractor">
        <rdf:type rdf:resource="&UvA-SA-ontology;Component"/>
        <rdfs:label>Extractor</rdfs:label>
        <UvA-SA-ontology:name>Extractor</UvA-SA-ontology:name>
        <UvA-SA-ontology:description>The extractor within the data layer is a component that connects to a tool’s (an instance of a tool type) data source. After successfully establishing a connection, it will extract all of the available data from the tool as long as that data wasn’t included in any previous extraction. This extraction can happen at a scheduled interval, which can either be determined by a learning system or a fixed schedule, or it happens through a push mechanism (whenever data in a tool gets updated, extract the data)

The extractor component is also known as &#39;Data Collector&#39;</UvA-SA-ontology:description>
        <UvA-SA-ontology:is_modeled_in rdf:resource="&UvA-SA-ontology;component_model"/>
        <UvA-SA-ontology:part_of rdf:resource="&UvA-SA-ontology;data_layer"/>
        <UvA-SA-ontology:gathers_data rdf:resource="&Ontology1308582601209;Bugtracking_tools"/>
        <UvA-SA-ontology:gathers_data rdf:resource="&Ontology1308582601209;Communication_tools_"/>
        <UvA-SA-ontology:satisfies rdf:resource="&Ontology1308582601209;Criticality_of_existing_tools"/>
        <UvA-SA-ontology:is_modeled_in rdf:resource="&Ontology1308582601209;Deployment_diagram_-_Primary_presentation"/>
        <UvA-SA-ontology:gathers_data rdf:resource="&Ontology1308582601209;Project_management_tools"/>
        <realizes rdf:resource="&Ontology1308582601209;Scheduler"/>
        <UvA-SA-ontology:satisfies rdf:resource="&Ontology1308582601209;Tool_data_extraction"/>
        <realizes rdf:resource="&Ontology1308582601209;Transforming_data"/>
        <UvA-SA-ontology:gathers_data rdf:resource="&Ontology1308582601209;Versioning_tools_"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Fired_query -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Fired_query">
        <rdf:type rdf:resource="&Ontology1308582601209;Behaviour"/>
        <rdfs:label>Fire query</rdfs:label>
        <UvA-SA-ontology:name>Fire query</UvA-SA-ontology:name>
        <Provided_by rdf:resource="&Ontology1308582601209;Query_consolidator"/>
        <UvA-SA-ontology:is_modeled_in rdf:resource="&Ontology1308582601209;UML_SD_-_Fire_query"/>
        <Provided_by rdf:resource="&Ontology1308582601209;Various_client_components"/>
        <Provided_by rdf:resource="&Ontology1308582601209;representation_API_"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Flexibility -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Flexibility">
        <rdf:type rdf:resource="&UvA-SA-ontology;Non_functional_requirement"/>
        <rdfs:label>Flexibility</rdfs:label>
        <UvA-SA-ontology:name>Flexibility</UvA-SA-ontology:name>
        <UvA-SA-ontology:realized_by rdf:resource="&Ontology1308582601209;Business_rules_engine"/>
        <addressed_by rdf:resource="&Ontology1308582601209;Distribution_of_data_schema_for_tool_types"/>
        <UvA-SA-ontology:related_to rdf:resource="&Ontology1308582601209;Extensibility_of_data_sources"/>
        <UvA-SA-ontology:related_to rdf:resource="&Ontology1308582601209;Maintainability"/>
        <addressed_by rdf:resource="&Ontology1308582601209;Method_of_data_gathering"/>
        <UvA-SA-ontology:related_to rdf:resource="&Ontology1308582601209;Provide_Application_Programming_Interface_(API)"/>
        <UvA-SA-ontology:results_in rdf:resource="&Ontology1308582601209;Scheduler"/>
        <UvA-SA-ontology:realized_by rdf:resource="&Ontology1308582601209;Scheduler"/>
        <addressed_by rdf:resource="&Ontology1308582601209;Storage_of_extracted_data"/>
        <UvA-SA-ontology:related_to rdf:resource="&Ontology1308582601209;creation_of_multiple_front-ends"/>
        <UvA-SA-ontology:realized_by rdf:resource="&Ontology1308582601209;relational_database"/>
        <UvA-SA-ontology:results_in rdf:resource="&Ontology1308582601209;relational_database"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Implementation_for_Mercurial -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Implementation_for_Mercurial">
        <rdf:type rdf:resource="&UvA-SA-ontology;Diagram"/>
        <rdfs:label>Implementation for Mercurial</rdfs:label>
        <UvA-SA-ontology:name>Implementation for Mercurial</UvA-SA-ontology:name>
        <UvA-SA-ontology:models rdf:resource="&Ontology1308582601209;Data_gatherer_extensibility"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Independent_Business_Logic_Layer -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Independent_Business_Logic_Layer">
        <rdf:type rdf:resource="&Ontology1308582601209;Design_issue"/>
        <rdfs:label>Depence of business logic layer</rdfs:label>
        <UvA-SA-ontology:decision_issue>Depence of business logic layer</UvA-SA-ontology:decision_issue>
        <UvA-SA-ontology:name>Depence of business logic layer</UvA-SA-ontology:name>
        <UvA-SA-ontology:description>We have chosen  to make this layer independent, as this system is not process-critical (therefore, data doesn’t need to be very accurate ) and it would safe performance , </UvA-SA-ontology:description>
        <UvA-SA-ontology:decision_is_about rdf:resource="&UvA-SA-ontology;Business_Logic_Layer"/>
        <UvA-SA-ontology:depends_on rdf:resource="&Ontology1308582601209;Performance"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Infrastructure_context_diagram -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Infrastructure_context_diagram">
        <rdf:type rdf:resource="&UvA-SA-ontology;Diagram"/>
        <rdfs:label>Infrastructure context diagram</rdfs:label>
        <UvA-SA-ontology:description>The diagram is a replication of the existing infrastructure as supplied by the stakeholder. It consists of two separated diagrams: one for the headquarter site in Amsterdam and one for all non-headquarter sites.</UvA-SA-ontology:description>
        <UvA-SA-ontology:name>Infrastructure context diagram</UvA-SA-ontology:name>
        <UvA-SA-ontology:models rdf:resource="&Ontology1308582601209;Application_server"/>
        <UvA-SA-ontology:models rdf:resource="&Ontology1308582601209;Database_server"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Interfaces_for_extracting_and_transforming_data_ -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Interfaces_for_extracting_and_transforming_data_">
        <rdf:type rdf:resource="&UvA-SA-ontology;Diagram"/>
        <rdfs:label>Interfaces for extracting and transforming data </rdfs:label>
        <UvA-SA-ontology:name>Interfaces for extracting and transforming data </UvA-SA-ontology:name>
        <UvA-SA-ontology:models rdf:resource="&Ontology1308582601209;Data_gatherer_extensibility"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Internal_representation_of_a_commit -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Internal_representation_of_a_commit">
        <rdf:type rdf:resource="&UvA-SA-ontology;Diagram"/>
        <rdfs:label>Internal representation of a commit</rdfs:label>
        <UvA-SA-ontology:name>Internal representation of a commit</UvA-SA-ontology:name>
        <UvA-SA-ontology:models rdf:resource="&Ontology1308582601209;Data_gatherer_extensibility"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Maintainability -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Maintainability">
        <rdf:type rdf:resource="&UvA-SA-ontology;Non_functional_requirement"/>
        <rdfs:label>Maintainability</rdfs:label>
        <UvA-SA-ontology:name>Maintainability</UvA-SA-ontology:name>
        <UvA-SA-ontology:realized_by rdf:resource="&Ontology1308582601209;Business_rules_engine"/>
        <UvA-SA-ontology:related_to rdf:resource="&Ontology1308582601209;Extensibility_of_data_sources"/>
        <UvA-SA-ontology:related_to rdf:resource="&Ontology1308582601209;Flexibility"/>
        <addressed_by rdf:resource="&Ontology1308582601209;Method_of_data_gathering"/>
        <UvA-SA-ontology:related_to rdf:resource="&Ontology1308582601209;Minimum_amount_of_configuration"/>
        <UvA-SA-ontology:related_to rdf:resource="&Ontology1308582601209;Provide_Application_Programming_Interface_(API)"/>
        <UvA-SA-ontology:realized_by rdf:resource="&Ontology1308582601209;Scheduler"/>
        <UvA-SA-ontology:results_in rdf:resource="&Ontology1308582601209;Scheduler"/>
        <UvA-SA-ontology:related_to rdf:resource="&Ontology1308582601209;creation_of_multiple_front-ends"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Make_data_derivations_and_aggregations_ -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Make_data_derivations_and_aggregations_">
        <rdf:type rdf:resource="&UvA-SA-ontology;Functional_requirement"/>
        <rdfs:label>Make data derivations and aggregations </rdfs:label>
        <UvA-SA-ontology:name>Make data derivations and aggregations </UvA-SA-ontology:name>
        <UvA-SA-ontology:realized_by rdf:resource="&Ontology1308582601209;Transformer_(business)"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Method_of_data_gathering -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Method_of_data_gathering">
        <rdf:type rdf:resource="&Ontology1308582601209;Design_issue"/>
        <rdfs:label>Method of data gathering</rdfs:label>
        <UvA-SA-ontology:decision_issue>Data should be gathered from tool types</UvA-SA-ontology:decision_issue>
        <UvA-SA-ontology:name>Method of data gathering</UvA-SA-ontology:name>
        <status>Decided</status>
        <UvA-SA-ontology:depends_on rdf:resource="&Ontology1308582601209;Cost"/>
        <UvA-SA-ontology:depends_on rdf:resource="&Ontology1308582601209;Criticality_of_existing_tools"/>
        <UvA-SA-ontology:depends_on rdf:resource="&Ontology1308582601209;Extensibility_of_data_sources"/>
        <UvA-SA-ontology:depends_on rdf:resource="&Ontology1308582601209;Flexibility"/>
        <UvA-SA-ontology:depends_on rdf:resource="&Ontology1308582601209;Maintainability"/>
        <UvA-SA-ontology:posit_design rdf:resource="&Ontology1308582601209;Periodic_listening_for_data_gathering"/>
        <UvA-SA-ontology:posit_design rdf:resource="&Ontology1308582601209;Periodic_queries_for_data_gathering"/>
        <UvA-SA-ontology:results_in rdf:resource="&Ontology1308582601209;Scheduler"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Minimum_amount_of_configuration -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Minimum_amount_of_configuration">
        <rdf:type rdf:resource="&UvA-SA-ontology;Non_functional_requirement"/>
        <rdf:type rdf:resource="&Ontology1308582601209;Concern"/>
        <rdfs:label>Minimum amount of configuration</rdfs:label>
        <UvA-SA-ontology:name>Minimum amount of configuration</UvA-SA-ontology:name>
        <UvA-SA-ontology:realized_by rdf:resource="&Ontology1308582601209;Application_server"/>
        <UvA-SA-ontology:related_to rdf:resource="&Ontology1308582601209;Choose_representation"/>
        <UvA-SA-ontology:realized_by rdf:resource="&Ontology1308582601209;Database_server"/>
        <UvA-SA-ontology:related_to rdf:resource="&Ontology1308582601209;Maintainability"/>
        <UvA-SA-ontology:is_concern_of rdf:resource="&Ontology1308582601209;Previous"/>
        <UvA-SA-ontology:related_to rdf:resource="&Ontology1308582601209;Transformation_of_gathered_data"/>
        <addressed_by rdf:resource="&Ontology1308582601209;configuration_is_applied_to_servers_directly"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Modifiability -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Modifiability">
        <rdf:type rdf:resource="&UvA-SA-ontology;Non_functional_requirement"/>
        <rdfs:label>Modifiability</rdfs:label>
        <UvA-SA-ontology:name>Modifiability</UvA-SA-ontology:name>
        <UvA-SA-ontology:related_to rdf:resource="&Ontology1308582601209;Extensibility_of_data_sources"/>
        <UvA-SA-ontology:related_to rdf:resource="&Ontology1308582601209;Flexibility"/>
        <UvA-SA-ontology:related_to rdf:resource="&Ontology1308582601209;Maintainability"/>
        <UvA-SA-ontology:related_to rdf:resource="&Ontology1308582601209;Modifiability"/>
        <UvA-SA-ontology:related_to rdf:resource="&Ontology1308582601209;Provide_Application_Programming_Interface_(API)"/>
        <UvA-SA-ontology:related_to rdf:resource="&Ontology1308582601209;Transformation_of_gathered_data"/>
        <addressed_by rdf:resource="&Ontology1308582601209;data_sources_of_application_need_to_be_extensible"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Modify_business_rules -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Modify_business_rules">
        <rdf:type rdf:resource="&Ontology1308582601209;Behaviour"/>
        <rdfs:label>Modify business rules</rdfs:label>
        <UvA-SA-ontology:name>Modify business rules</UvA-SA-ontology:name>
        <Provided_by rdf:resource="&Ontology1308582601209;Business_rules_engine"/>
        <Provided_by rdf:resource="&Ontology1308582601209;Configuration_Module"/>
        <UvA-SA-ontology:is_modeled_in rdf:resource="&Ontology1308582601209;UML_SD_-_Modyfying_business_rules"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Modify_received_tool_data -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Modify_received_tool_data">
        <rdf:type rdf:resource="&UvA-SA-ontology;Functional_requirement"/>
        <rdfs:label>Modify received tool data</rdfs:label>
        <UvA-SA-ontology:name>Modify received tool data</UvA-SA-ontology:name>
        <UvA-SA-ontology:realized_by rdf:resource="&Ontology1308582601209;Transformer"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#No_changes_to_existing_infrastructure -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;No_changes_to_existing_infrastructure">
        <rdf:type rdf:resource="&UvA-SA-ontology;Non_functional_requirement"/>
        <rdf:type rdf:resource="&Ontology1308582601209;Concern"/>
        <rdfs:label>No changes to existing infrastructure</rdfs:label>
        <UvA-SA-ontology:name>No changes to existing infrastructure</UvA-SA-ontology:name>
        <UvA-SA-ontology:realized_by rdf:resource="&Ontology1308582601209;Application_server"/>
        <UvA-SA-ontology:realized_by rdf:resource="&Ontology1308582601209;Database_server"/>
        <UvA-SA-ontology:is_concern_of rdf:resource="&Ontology1308582601209;Previous"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Only_a_subset_of_data_is_extracted_from_tools_ -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Only_a_subset_of_data_is_extracted_from_tools_">
        <rdf:type rdf:resource="&UvA-SA-ontology;Assumption"/>
        <rdfs:label>SNA system workload is lower than existing servers </rdfs:label>
        <UvA-SA-ontology:description>The SNA system extracts data from existing tool servers (eg. Jira, mail, etc.); specifically, it only extracts a subset of data from these servers . So it is assumed that the workload of the SNA system is lower than existing servers (which processes the full datasets)</UvA-SA-ontology:description>
        <UvA-SA-ontology:name>SNA system workload is lower than existing servers </UvA-SA-ontology:name>
        <UvA-SA-ontology:made_for rdf:resource="&Ontology1308582601209;two_separated_servers"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Partly_extensible_data_sources -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Partly_extensible_data_sources">
        <rdf:type rdf:resource="&UvA-SA-ontology;Design_Alternatives"/>
        <rdf:type rdf:resource="&UvA-SA-ontology;Scenario"/>
        <rdfs:label>Partially extensible data sources</rdfs:label>
        <UvA-SA-ontology:name>Partially extensible data sources</UvA-SA-ontology:name>
        <UvA-SA-ontology:description>partly extensible data sources – Fitted on the current situation, but with a flexibility to use systems with the same ways to process and retrieve the data.

In this scenario, the data sources are categorized. For instance, there is a category version control, a category contact, etc. All these categories provide an abstract data representation and an interface for the concrete implementation.</UvA-SA-ontology:description>
        <status>Accepted</status>
        <UvA-SA-ontology:arguments>The partly extensible-solution is also extensible, but more in a focused way. A new data source can be included, however the type of data source needs to be defined within the application already. For example, a new type of version control system can be included without changing the internal structure of the application, but for a completely new type of data source, the internal structure has to be modified  to support this type of data source.

The partly extensible-solution has abstractions on the type level, which makes it more complex compared to the current fit-solution. This is because the abstractions have to be researched and a general data representation has to be developed. This raises the complexity .

This solution is more difficult  to deploy because apart from the specific data source configuration, also the type of data source has to be configured. For instance, the application will not know out of the blue which instance of a version control system used or even how many version control systems are in operation within the organization, so this needs to be configured.</UvA-SA-ontology:arguments>
        <UvA-SA-ontology:supported_by rdf:resource="&Ontology1308582601209;Data_gathering"/>
        <UvA-SA-ontology:supported_by rdf:resource="&Ontology1308582601209;Partly_extensible_data_sources"/>
        <UvA-SA-ontology:based_on rdf:resource="&Ontology1308582601209;tools_will_more_frequently_change_than_tool_types."/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Performance -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Performance">
        <rdf:type rdf:resource="&UvA-SA-ontology;Non_functional_requirement"/>
        <rdf:type rdf:resource="&Ontology1308582601209;Concern"/>
        <rdfs:label>Performance</rdfs:label>
        <UvA-SA-ontology:description>Performance is one of the quality aspects the stakeholders  are concerned  about (they want a fast system, else it will probably not be used).</UvA-SA-ontology:description>
        <UvA-SA-ontology:name>Performance</UvA-SA-ontology:name>
        <UvA-SA-ontology:realized_by rdf:resource="&UvA-SA-ontology;Business_Logic_Layer"/>
        <UvA-SA-ontology:realized_by rdf:resource="&Ontology1308582601209;Analysis_database"/>
        <addressed_by rdf:resource="&Ontology1308582601209;Analysis_database_type"/>
        <addressed_by rdf:resource="&Ontology1308582601209;Distribution_of_data_schema_for_tool_types"/>
        <addressed_by rdf:resource="&Ontology1308582601209;Independent_Business_Logic_Layer"/>
        <UvA-SA-ontology:is_concern_of rdf:resource="&Ontology1308582601209;Previous"/>
        <addressed_by rdf:resource="&Ontology1308582601209;SNA_system_behaves_like_workstation_client"/>
        <addressed_by rdf:resource="&Ontology1308582601209;Storage_of_extracted_data"/>
        <UvA-SA-ontology:realized_by rdf:resource="&Ontology1308582601209;relational_database"/>
        <UvA-SA-ontology:results_in rdf:resource="&Ontology1308582601209;relational_database"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Periodic_listening_for_data_gathering -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Periodic_listening_for_data_gathering">
        <rdf:type rdf:resource="&UvA-SA-ontology;Design_Alternatives"/>
        <rdfs:label>Periodic listening for data gathering</rdfs:label>
        <UvA-SA-ontology:arguments>Advantages: Small requests

Disadvantages: A lot of requests to gather the needed information.+ In other cases an extra plug-in need to be installed in the source systems to listen on changes.</UvA-SA-ontology:arguments>
        <status>Rejected</status>
        <UvA-SA-ontology:description>This option uses periodic listening for changes, for example in the SVN case listening for a commit.</UvA-SA-ontology:description>
        <UvA-SA-ontology:name>Periodic listening for data gathering</UvA-SA-ontology:name>
        <UvA-SA-ontology:supported_by rdf:resource="&Ontology1308582601209;Data_gatherer_extensibility"/>
        <UvA-SA-ontology:supported_by rdf:resource="&Ontology1308582601209;Data_gathering"/>
        <UvA-SA-ontology:based_on rdf:resource="&Ontology1308582601209;There_is_a_way_to_extract_data_from_each_critical_system_"/>
        <UvA-SA-ontology:based_on rdf:resource="&Ontology1308582601209;tools_will_more_frequently_change_than_tool_types."/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Periodic_queries_for_data_gathering -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Periodic_queries_for_data_gathering">
        <rdf:type rdf:resource="&UvA-SA-ontology;Design_Alternatives"/>
        <rdfs:label>Periodic queries for data gathering</rdfs:label>
        <UvA-SA-ontology:description>This option uses different libraries, API’S or connector per tool type. This will be periodically and based on querying.</UvA-SA-ontology:description>
        <UvA-SA-ontology:name>Periodic queries for data gathering</UvA-SA-ontology:name>
        <UvA-SA-ontology:arguments>This option gives standardised and well proved libraries access to the databases or source systems to gather the information

Advantages: Use of given and common ways to query the source systems. + Free libraries and connectors mostly given.

Disadvantages: Need change for data access changes</UvA-SA-ontology:arguments>
        <status>Accepted</status>
        <UvA-SA-ontology:supported_by rdf:resource="&Ontology1308582601209;Data_gatherer_extensibility"/>
        <UvA-SA-ontology:supported_by rdf:resource="&Ontology1308582601209;Data_gathering"/>
        <UvA-SA-ontology:based_on rdf:resource="&Ontology1308582601209;There_is_a_way_to_extract_data_from_each_critical_system_"/>
        <UvA-SA-ontology:based_on rdf:resource="&Ontology1308582601209;tools_will_more_frequently_change_than_tool_types."/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Previous -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Previous">
        <rdf:type rdf:resource="&UvA-SA-ontology;Stakeholder"/>
        <rdfs:label>Previous</rdfs:label>
        <UvA-SA-ontology:description>Previous are the main/most improtant stakeholder group (contractors) of the SNA system

They are also refered to as &#39;customer&#39;</UvA-SA-ontology:description>
        <UvA-SA-ontology:name>Previous</UvA-SA-ontology:name>
        <UvA-SA-ontology:concerned_about rdf:resource="&Ontology1308582601209;Availability"/>
        <UvA-SA-ontology:concerned_about rdf:resource="&Ontology1308582601209;Conformance_to_existing_security_regulations"/>
        <UvA-SA-ontology:concerned_about rdf:resource="&Ontology1308582601209;Criticality_of_existing_tools"/>
        <UvA-SA-ontology:concerned_about rdf:resource="&Ontology1308582601209;Extensibility_of_data_sources"/>
        <UvA-SA-ontology:concerned_about rdf:resource="&Ontology1308582601209;Minimum_amount_of_configuration"/>
        <UvA-SA-ontology:concerned_about rdf:resource="&Ontology1308582601209;No_changes_to_existing_infrastructure"/>
        <UvA-SA-ontology:concerned_about rdf:resource="&Ontology1308582601209;Performance"/>
        <UvA-SA-ontology:concerned_about rdf:resource="&Ontology1308582601209;Provide_Application_Programming_Interface_(API)"/>
        <UvA-SA-ontology:concerned_about rdf:resource="&Ontology1308582601209;creation_of_multiple_front-ends"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Project_management_tools -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Project_management_tools">
        <rdf:type rdf:resource="&UvA-SA-ontology;Data_store"/>
        <rdf:type rdf:resource="&UvA-SA-ontology;Tool"/>
        <rdfs:label>Project management tools</rdfs:label>
        <UvA-SA-ontology:description>Project management tools are used to keep track of the current status of a project team. It lists TO-DO items, features a planning mechanism and some form of reporting for superiors

Examples of Project management tools are: JIRA, Redmine</UvA-SA-ontology:description>
        <UvA-SA-ontology:name>Project management tools</UvA-SA-ontology:name>
        <UvA-SA-ontology:is_modeled_in rdf:resource="&Ontology1308582601209;Context_diagram"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Provide_Application_Programming_Interface_(API) -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Provide_Application_Programming_Interface_(API)">
        <rdf:type rdf:resource="&UvA-SA-ontology;Functional_requirement"/>
        <rdf:type rdf:resource="&Ontology1308582601209;Concern"/>
        <rdfs:label>Provide Application Programming Interface (API)</rdfs:label>
        <UvA-SA-ontology:description>The stakeholders  have said that they would like an  API  so they could hook up external applications to it easily</UvA-SA-ontology:description>
        <UvA-SA-ontology:name>Provide Application Programming Interface (API)</UvA-SA-ontology:name>
        <UvA-SA-ontology:is_concern_of rdf:resource="&Ontology1308582601209;Previous"/>
        <UvA-SA-ontology:realized_by rdf:resource="&Ontology1308582601209;representation_API_"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Pull_data -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Pull_data">
        <rdf:type rdf:resource="&UvA-SA-ontology;Design_Alternatives"/>
        <rdfs:label>Pull data</rdfs:label>
        <UvA-SA-ontology:name>Pull data</UvA-SA-ontology:name>
        <UvA-SA-ontology:description>store the data abstracted by the transformation module in the data layer and the data processed in the business layer in their own databases. The data can in this case periodically be retrieved from the databases and processed.</UvA-SA-ontology:description>
        <UvA-SA-ontology:arguments>Advantages: complete control over when to receive data from what sources, data can be pre-coupled before persisted to the final database. + compatability with tools

Disadvantages: deciding when to retrieve data from the critical systems is not at all trivial (could be overcome with some monitoring software however)

it is possible to use monitoring software to measure when to pull data from an external source. Since the compatability problem of the alternaive option can be overcome this way, there is really no argument left why not to choose for a pull-strategy.</UvA-SA-ontology:arguments>
        <status>Accepted</status>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Push_data -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Push_data">
        <rdf:type rdf:resource="&UvA-SA-ontology;Design_Alternatives"/>
        <rdfs:label>Push data</rdfs:label>
        <status>Rejected</status>
        <UvA-SA-ontology:name>Push data</UvA-SA-ontology:name>
        <UvA-SA-ontology:description>Pushing data from one layer to another when ready up to the data storage at the end. This performed very puristicly, the data extractors wouldn’t so much be extractors but API’s that are able to receive data from the appropriate sources.</UvA-SA-ontology:description>
        <UvA-SA-ontology:arguments>However the solution has some problems: Not all applications can be integrated into the system.

it appears that pushing the data only as a single major advantage: the fact that the critical systems can decide when they have sufficient resources available for pushing their code to the application. 

The biggest disadvantage however, the fact that not all systems are compatible with this solution is reason enough to discard the idea. 

advantages: control when to push at tool - performance

Disadvantages: no control when data is pushed + not compatible with all tools</UvA-SA-ontology:arguments>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Query_Consolidator_is_not_separate_from_the_API -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Query_Consolidator_is_not_separate_from_the_API">
        <rdf:type rdf:resource="&UvA-SA-ontology;Design_Alternatives"/>
        <rdfs:label>Query Consolidator is not separate from the API</rdfs:label>
        <status>Rejected</status>
        <UvA-SA-ontology:name>Query Consolidator is not separate from the API</UvA-SA-ontology:name>
        <UvA-SA-ontology:decision_issue>What needed to be decided was whether to make the Query Consolidator separate from the API  or not . </UvA-SA-ontology:decision_issue>
        <UvA-SA-ontology:decision_is_about rdf:resource="&Ontology1308582601209;Query_consolidator"/>
        <UvA-SA-ontology:decision_is_about rdf:resource="&Ontology1308582601209;representation_API_"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Query_Consolidator_separate_from_the_API -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Query_Consolidator_separate_from_the_API">
        <rdf:type rdf:resource="&Ontology1308582601209;Design_issue"/>
        <rdfs:label>Query Consolidator relation to API</rdfs:label>
        <UvA-SA-ontology:decision_issue>What needed to be decided was whether to make the Query Consolidator separate from the API  or not . </UvA-SA-ontology:decision_issue>
        <status>Decided</status>
        <UvA-SA-ontology:design_decision>Controllers should not contain any logic; this is a task for the services.</UvA-SA-ontology:design_decision>
        <UvA-SA-ontology:name>Query Consolidator relation to API</UvA-SA-ontology:name>
        <UvA-SA-ontology:decision_is_about rdf:resource="&Ontology1308582601209;Query_consolidator"/>
        <UvA-SA-ontology:decision_is_about rdf:resource="&Ontology1308582601209;representation_API_"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Query_consolidator -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Query_consolidator">
        <rdf:type rdf:resource="&UvA-SA-ontology;Component"/>
        <rdfs:label>Query consolidator</rdfs:label>
        <UvA-SA-ontology:name>Query consolidator</UvA-SA-ontology:name>
        <UvA-SA-ontology:part_of rdf:resource="&UvA-SA-ontology;Representation_Layer"/>
        <UvA-SA-ontology:is_modeled_in rdf:resource="&UvA-SA-ontology;component_model"/>
        <realizes rdf:resource="&Ontology1308582601209;Fired_query"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Rule_handling -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Rule_handling">
        <rdf:type rdf:resource="&UvA-SA-ontology;Functional_requirement"/>
        <rdfs:label>Rule handling for deciding experitise</rdfs:label>
        <UvA-SA-ontology:name>Rule handling for deciding experitise</UvA-SA-ontology:name>
        <UvA-SA-ontology:description>Making connections between users  is relatively simple, for example in an email the sender and recipient can be connected, but deciding when a user is an expert for example is a lot different. There is no obvious way to decide when a user is an expert, there is some sort of rule required to decide when this is the case.

Thus, to achieve this goal some sort of rule handling is required . </UvA-SA-ontology:description>
        <UvA-SA-ontology:results_in rdf:resource="&Ontology1308582601209;Business_rules_engine"/>
        <UvA-SA-ontology:realized_by rdf:resource="&Ontology1308582601209;Business_rules_engine"/>
        <addressed_by rdf:resource="&Ontology1308582601209;Rule_handling_for_processing_data"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Rule_handling_for_processing_data -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Rule_handling_for_processing_data">
        <rdf:type rdf:resource="&Ontology1308582601209;Design_issue"/>
        <rdfs:label>Rule handling for processing data</rdfs:label>
        <status>Decided</status>
        <UvA-SA-ontology:design_decision>The use of a business rules engine is more fit for the problem in our opinion, because of the straight-forwardness of rule adaption as well as the fact that it’s an industry-standard practice. The fact that it introduces a bit of complexity  is not reason enough to discard the idea, especially since the alternative solution does the same in a different space.</UvA-SA-ontology:design_decision>
        <UvA-SA-ontology:name>Rule handling for processing data</UvA-SA-ontology:name>
        <UvA-SA-ontology:decision_issue>After the data has been abstracted and gathered, it still needs to be processed. It is useful to have already assigned some properties to users  (such as: “is expert on”) and to have made connections between users.</UvA-SA-ontology:decision_issue>
        <UvA-SA-ontology:decision_is_about rdf:resource="&UvA-SA-ontology;Business_Logic_Layer"/>
        <UvA-SA-ontology:results_in rdf:resource="&Ontology1308582601209;Business_rules_engine"/>
        <UvA-SA-ontology:depends_on rdf:resource="&Ontology1308582601209;Complexity"/>
        <UvA-SA-ontology:depends_on rdf:resource="&Ontology1308582601209;Rule_handling"/>
        <UvA-SA-ontology:posit_design rdf:resource="&Ontology1308582601209;Use_of_business_rules_engine"/>
        <UvA-SA-ontology:posit_design rdf:resource="&Ontology1308582601209;Use_of_hard-coded_rules"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#SNA_system_behaves_like_workstation_client -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;SNA_system_behaves_like_workstation_client">
        <rdf:type rdf:resource="&Ontology1308582601209;Design_issue"/>
        <rdfs:label>Tool connection behaviour of system</rdfs:label>
        <UvA-SA-ontology:design_decision>The SNA system behaves like a workstation client  when connecting to existing tool servers and therefore stresses a minimal additional load  on these servers.</UvA-SA-ontology:design_decision>
        <status>Decided</status>
        <UvA-SA-ontology:name>Tool connection behaviour of system</UvA-SA-ontology:name>
        <UvA-SA-ontology:decision_issue>How should the SNA system present itself to existing tools</UvA-SA-ontology:decision_issue>
        <UvA-SA-ontology:depends_on rdf:resource="&Ontology1308582601209;Performance"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Scheduler -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Scheduler">
        <rdf:type rdf:resource="&Ontology1308582601209;Behaviour"/>
        <rdfs:label>Scheduler</rdfs:label>
        <UvA-SA-ontology:name>Scheduler</UvA-SA-ontology:name>
        <UvA-SA-ontology:satisfies rdf:resource="&Ontology1308582601209;Criticality_of_existing_tools"/>
        <UvA-SA-ontology:satisfies rdf:resource="&Ontology1308582601209;Extensibility_of_data_sources"/>
        <Provided_by rdf:resource="&Ontology1308582601209;Extractor"/>
        <UvA-SA-ontology:satisfies rdf:resource="&Ontology1308582601209;Flexibility"/>
        <UvA-SA-ontology:satisfies rdf:resource="&Ontology1308582601209;Maintainability"/>
        <UvA-SA-ontology:satisfies rdf:resource="&Ontology1308582601209;Tool_data_extraction_at_scheduled_interval"/>
        <Provided_by rdf:resource="&Ontology1308582601209;Transformer"/>
        <UvA-SA-ontology:is_modeled_in rdf:resource="&Ontology1308582601209;UML_SD_-_scheduling"/>
        <Provided_by rdf:resource="&Ontology1308582601209;relational_database"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Security -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Security">
        <rdf:type rdf:resource="&UvA-SA-ontology;Non_functional_requirement"/>
        <rdfs:label>Security</rdfs:label>
        <UvA-SA-ontology:name>Security</UvA-SA-ontology:name>
        <UvA-SA-ontology:realized_by rdf:resource="&Ontology1308582601209;Application_server"/>
        <UvA-SA-ontology:related_to rdf:resource="&Ontology1308582601209;Conformance_to_existing_security_regulations"/>
        <UvA-SA-ontology:realized_by rdf:resource="&Ontology1308582601209;Database_server"/>
        <addressed_by rdf:resource="&Ontology1308582601209;Distribution_of_data_schema_for_tool_types"/>
        <addressed_by rdf:resource="&Ontology1308582601209;Storage_of_extracted_data"/>
        <UvA-SA-ontology:realized_by rdf:resource="&Ontology1308582601209;relational_database"/>
        <UvA-SA-ontology:results_in rdf:resource="&Ontology1308582601209;relational_database"/>
        <UvA-SA-ontology:realized_by rdf:resource="&Ontology1308582601209;representation_API_"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Storage_of_analysis_data -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Storage_of_analysis_data">
        <rdf:type rdf:resource="&UvA-SA-ontology;Functional_requirement"/>
        <rdfs:label>Storage of analysis data</rdfs:label>
        <UvA-SA-ontology:description>Analysis data needs to be stored in some sort of database.</UvA-SA-ontology:description>
        <UvA-SA-ontology:name>Storage of analysis data</UvA-SA-ontology:name>
        <UvA-SA-ontology:realized_by rdf:resource="&Ontology1308582601209;Analysis_database"/>
        <addressed_by rdf:resource="&Ontology1308582601209;Analysis_database_type"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Storage_of_extracted_data -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Storage_of_extracted_data">
        <rdf:type rdf:resource="&Ontology1308582601209;Design_issue"/>
        <rdfs:label>Storage of extracted data</rdfs:label>
        <UvA-SA-ontology:decision_issue>The data collector(extractor) needs to temporary stores his extracted data, to provide them to the SNA component. The data collector can accomplish that in two ways, store them in a database or in separate flat file formats, like xml, CSV or an own simple data structure</UvA-SA-ontology:decision_issue>
        <UvA-SA-ontology:name>Storage of extracted data</UvA-SA-ontology:name>
        <UvA-SA-ontology:design_decision>The data store used for the extracted and transformed data from the source systems will be stored in a database system with several database schemas per tool type (Source system type).

The extracted data from every systems will be transformed in a format which gives only the information’s needed and this data will be then stored for further processing through the SNA component</UvA-SA-ontology:design_decision>
        <status>Decided</status>
        <UvA-SA-ontology:depends_on rdf:resource="&Ontology1308582601209;Cost"/>
        <UvA-SA-ontology:depends_on rdf:resource="&Ontology1308582601209;Data_integrity"/>
        <UvA-SA-ontology:depends_on rdf:resource="&Ontology1308582601209;Flexibility"/>
        <UvA-SA-ontology:depends_on rdf:resource="&Ontology1308582601209;Performance"/>
        <UvA-SA-ontology:depends_on rdf:resource="&Ontology1308582601209;Security"/>
        <UvA-SA-ontology:posit_design rdf:resource="&Ontology1308582601209;Store_data_in_database"/>
        <UvA-SA-ontology:results_in rdf:resource="&Ontology1308582601209;relational_database"/>
        <UvA-SA-ontology:posit_design rdf:resource="&Ontology1308582601209;store_data_in_flat_file_format"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Store_data_in_database -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Store_data_in_database">
        <rdf:type rdf:resource="&UvA-SA-ontology;Design_Alternatives"/>
        <rdfs:label>Store data in database</rdfs:label>
        <status>Accepted</status>
        <UvA-SA-ontology:arguments>Advantages: Multi access, read &amp; write + Transaction save + Relation between data + Optimized data storing

Disadvantages: Extra costs + Extra connector libs needed</UvA-SA-ontology:arguments>
        <UvA-SA-ontology:name>Store data in database</UvA-SA-ontology:name>
        <UvA-SA-ontology:posit_design rdf:resource="&Ontology1308582601209;store_data_in_flat_file_format"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Support_tool_switch -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Support_tool_switch">
        <rdf:type rdf:resource="&Ontology1308582601209;Design_issue"/>
        <rdfs:label>Support known tool switch</rdfs:label>
        <UvA-SA-ontology:decision_issue>stakeholders like to experiment with different tools. At the moment they might use a specific tool, but if another, better tool arises, there is a large probability that they are going to experiment with it. </UvA-SA-ontology:decision_issue>
        <UvA-SA-ontology:name>Support known tool switch</UvA-SA-ontology:name>
        <status>Accepted</status>
        <UvA-SA-ontology:description>One of the design decisions was that the architecture will support switching to another tool of a known type. </UvA-SA-ontology:description>
        <UvA-SA-ontology:depends_on rdf:resource="&Ontology1308582601209;Extensibility_of_data_sources"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#There_is_a_way_to_extract_data_from_each_critical_system_ -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;There_is_a_way_to_extract_data_from_each_critical_system_">
        <rdf:type rdf:resource="&UvA-SA-ontology;Assumption"/>
        <rdfs:label>There is a way to extract data from each critical system </rdfs:label>
        <UvA-SA-ontology:name>There is a way to extract data from each critical system </UvA-SA-ontology:name>
        <UvA-SA-ontology:description>Some assumptions that we have made when working out this design is that there is a way to extract data from each critical system . This could be by using an API or reading data from a file processed by it, but there must be SOME way. An application that outputs no data to an accessible source is not useable for this type of problem.</UvA-SA-ontology:description>
        <UvA-SA-ontology:made_for rdf:resource="&Ontology1308582601209;Periodic_listening_for_data_gathering"/>
        <UvA-SA-ontology:made_for rdf:resource="&Ontology1308582601209;Periodic_queries_for_data_gathering"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Tool_data_extraction -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Tool_data_extraction">
        <rdf:type rdf:resource="&UvA-SA-ontology;Functional_requirement"/>
        <rdfs:label>Tool data extraction</rdfs:label>
        <UvA-SA-ontology:description>The extractor component should extract all of the available data from the tools as long as that data wasn’t included in any previous extraction </UvA-SA-ontology:description>
        <UvA-SA-ontology:name>Tool data extraction</UvA-SA-ontology:name>
        <UvA-SA-ontology:realized_by rdf:resource="&Ontology1308582601209;Extractor"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Tool_data_extraction_at_scheduled_interval -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Tool_data_extraction_at_scheduled_interval">
        <rdf:type rdf:resource="&UvA-SA-ontology;Functional_requirement"/>
        <rdfs:label>Tool data extraction at scheduled interval</rdfs:label>
        <UvA-SA-ontology:description>extraction can happen at a scheduled interval, which can either be determined by a learning system or a fixed schedule , or it happens through a push mechanism (whenever data in a tool gets updated, extract the data </UvA-SA-ontology:description>
        <UvA-SA-ontology:name>Tool data extraction at scheduled interval</UvA-SA-ontology:name>
        <UvA-SA-ontology:realized_by rdf:resource="&Ontology1308582601209;Scheduler"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Transformation_of_gathered_data -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Transformation_of_gathered_data">
        <rdf:type rdf:resource="&UvA-SA-ontology;Functional_requirement"/>
        <rdfs:label>Transformation of gathered data</rdfs:label>
        <UvA-SA-ontology:description>The system should transform initially gathered data to a format that is more easily accessible and analysable</UvA-SA-ontology:description>
        <UvA-SA-ontology:name>Transformation of gathered data</UvA-SA-ontology:name>
        <UvA-SA-ontology:results_in rdf:resource="&Ontology1308582601209;Configuration_Module"/>
        <addressed_by rdf:resource="&Ontology1308582601209;Data_conversion_by_users"/>
        <UvA-SA-ontology:realized_by rdf:resource="&Ontology1308582601209;Transformer"/>
        <UvA-SA-ontology:realized_by rdf:resource="&Ontology1308582601209;Transformer_(business)"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Transformer -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Transformer">
        <rdf:type rdf:resource="&UvA-SA-ontology;Component"/>
        <rdfs:label>Transformer</rdfs:label>
        <UvA-SA-ontology:description>The transformer component will make modifications to the data it receives so that it can be mapped for storage in a relational database. The structuring of the data is determined by the tool type information that should be provided.</UvA-SA-ontology:description>
        <UvA-SA-ontology:name>Transformer</UvA-SA-ontology:name>
        <UvA-SA-ontology:is_modeled_in rdf:resource="&UvA-SA-ontology;component_model"/>
        <UvA-SA-ontology:part_of rdf:resource="&UvA-SA-ontology;data_layer"/>
        <UvA-SA-ontology:satisfies rdf:resource="&Ontology1308582601209;Modify_received_tool_data"/>
        <realizes rdf:resource="&Ontology1308582601209;Scheduler"/>
        <UvA-SA-ontology:satisfies rdf:resource="&Ontology1308582601209;Transformation_of_gathered_data"/>
        <realizes rdf:resource="&Ontology1308582601209;Transforming_data"/>
        <UvA-SA-ontology:stores_data rdf:resource="&Ontology1308582601209;relational_database"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Transformer_(business) -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Transformer_(business)">
        <rdf:type rdf:resource="&UvA-SA-ontology;Component"/>
        <rdfs:label>Transformer (business)</rdfs:label>
        <UvA-SA-ontology:name>Transformer (business)</UvA-SA-ontology:name>
        <UvA-SA-ontology:description>The transformer in this layer uses the data from this layer’s extractor, along with business rules set in the business rules engine in order to transform the data from the relational database into a format accepted by the analysis database. This analysis database will most likely be a graph database (as explained later on in this chapter). This means that the transformer has the following 2 jobs: 1) convert the data from the relational database into a format accepted by the graph database and 2) derivations and aggregations must be made on the data.</UvA-SA-ontology:description>
        <UvA-SA-ontology:part_of rdf:resource="&UvA-SA-ontology;Business_Logic_Layer"/>
        <UvA-SA-ontology:is_modeled_in rdf:resource="&UvA-SA-ontology;component_model"/>
        <UvA-SA-ontology:stores_data rdf:resource="&Ontology1308582601209;Analysis_database"/>
        <UvA-SA-ontology:satisfies rdf:resource="&Ontology1308582601209;Make_data_derivations_and_aggregations_"/>
        <UvA-SA-ontology:satisfies rdf:resource="&Ontology1308582601209;Transformation_of_gathered_data"/>
        <UvA-SA-ontology:satisfies rdf:resource="&Ontology1308582601209;convert_data"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Transforming_data -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Transforming_data">
        <rdf:type rdf:resource="&Ontology1308582601209;Behaviour"/>
        <rdfs:label>Transforming data</rdfs:label>
        <UvA-SA-ontology:name>Transforming data</UvA-SA-ontology:name>
        <Provided_by rdf:resource="&Ontology1308582601209;Analysis_database"/>
        <Provided_by rdf:resource="&Ontology1308582601209;Business_rules_engine"/>
        <Provided_by rdf:resource="&Ontology1308582601209;Extractor"/>
        <Provided_by rdf:resource="&Ontology1308582601209;Transformer"/>
        <UvA-SA-ontology:is_modeled_in rdf:resource="&Ontology1308582601209;UML_SD_-_Transforming_data"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#UML_SD_-_Fire_query -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;UML_SD_-_Fire_query">
        <rdf:type rdf:resource="&UvA-SA-ontology;Diagram"/>
        <rdfs:label>UML SD - Fire query</rdfs:label>
        <UvA-SA-ontology:name>UML SD - Fire query</UvA-SA-ontology:name>
        <UvA-SA-ontology:models rdf:resource="&Ontology1308582601209;Fired_query"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#UML_SD_-_Modyfying_business_rules -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;UML_SD_-_Modyfying_business_rules">
        <rdf:type rdf:resource="&UvA-SA-ontology;Diagram"/>
        <rdfs:label>UML SD - Modyfying business rules</rdfs:label>
        <UvA-SA-ontology:name>UML SD - Modyfying business rules</UvA-SA-ontology:name>
        <UvA-SA-ontology:models rdf:resource="&Ontology1308582601209;Modify_business_rules"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#UML_SD_-_Transforming_data -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;UML_SD_-_Transforming_data">
        <rdf:type rdf:resource="&UvA-SA-ontology;Diagram"/>
        <rdfs:label>UML SD - Transforming data</rdfs:label>
        <UvA-SA-ontology:name>UML SD - Transforming data</UvA-SA-ontology:name>
        <UvA-SA-ontology:models rdf:resource="&Ontology1308582601209;Transforming_data"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#UML_SD_-_scheduling -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;UML_SD_-_scheduling">
        <rdf:type rdf:resource="&UvA-SA-ontology;Diagram"/>
        <rdfs:label>UML SD - data layer scheduling</rdfs:label>
        <UvA-SA-ontology:name>UML SD - scheduling</UvA-SA-ontology:name>
        <UvA-SA-ontology:models rdf:resource="&Ontology1308582601209;Scheduler"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Use_of_business_rules_engine -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Use_of_business_rules_engine">
        <rdf:type rdf:resource="&UvA-SA-ontology;Design_Alternatives"/>
        <rdfs:label>Use of business rules engine</rdfs:label>
        <UvA-SA-ontology:name>Use of business rules engine</UvA-SA-ontology:name>
        <UvA-SA-ontology:arguments>Advantages: Lower complexity and Better maintainability  due to proven technology, better evailability due to runtime editing

Disadvantages: Higher complexity of total system due to extra module</UvA-SA-ontology:arguments>
        <status>Accepted</status>
        <UvA-SA-ontology:description>A business rules engine is a generic module that can depend on rules from an external source, such as a text file or database. </UvA-SA-ontology:description>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Use_of_hard-coded_rules -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Use_of_hard-coded_rules">
        <rdf:type rdf:resource="&UvA-SA-ontology;Design_Alternatives"/>
        <rdfs:label>Use of hard-coded rules</rdfs:label>
        <UvA-SA-ontology:description>If the logic is hard-coded, there is no need for another external module to communicate with.</UvA-SA-ontology:description>
        <UvA-SA-ontology:decision_issue>There is no obvious way to decide when a user is an expert, there is some sort of rule required to decide when this is the case.</UvA-SA-ontology:decision_issue>
        <UvA-SA-ontology:arguments>Advantages: less complexity: no interdependencies 

Disadvantages: Increase in size and complexity business logic layer + low maintainability + low flexibility + </UvA-SA-ontology:arguments>
        <UvA-SA-ontology:name>Use of hard-coded rules</UvA-SA-ontology:name>
        <status>Rejected</status>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Various_client_components -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Various_client_components">
        <rdf:type rdf:resource="&UvA-SA-ontology;Component"/>
        <rdfs:label>Various client components</rdfs:label>
        <UvA-SA-ontology:name>Various client components</UvA-SA-ontology:name>
        <UvA-SA-ontology:description>Based on Previous’  wish, it is possible to create multiple front-ends . All of these front-ends (clients) will use the API for their data access. The design of each client is therefore not important for the overall architecture, as Previous has yet to decide the types of front-ends they would like to use and the API is in all cases the central building block to each front-end.</UvA-SA-ontology:description>
        <UvA-SA-ontology:part_of rdf:resource="&UvA-SA-ontology;Representation_Layer"/>
        <UvA-SA-ontology:is_modeled_in rdf:resource="&UvA-SA-ontology;component_model"/>
        <realizes rdf:resource="&Ontology1308582601209;Fired_query"/>
        <UvA-SA-ontology:satisfies rdf:resource="&Ontology1308582601209;creation_of_multiple_front-ends"/>
        <UvA-SA-ontology:communicates_with rdf:resource="&Ontology1308582601209;user"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#Versioning_tools_ -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;Versioning_tools_">
        <rdf:type rdf:resource="&UvA-SA-ontology;Data_store"/>
        <rdf:type rdf:resource="&UvA-SA-ontology;Tool"/>
        <rdfs:label>Versioning tools </rdfs:label>
        <UvA-SA-ontology:description>Versioning tools are tools used by software developers to keep track of item versions. Each time a developer wishes to update a line of code in some file and commits this change through the versioning tool, the tool will assign a higher version to the modified item and will keep track of any changes made to the item.

Exampels of versioning tools  are: SVN, Mercurial</UvA-SA-ontology:description>
        <UvA-SA-ontology:name>Versioning tools </UvA-SA-ontology:name>
        <UvA-SA-ontology:is_modeled_in rdf:resource="&Ontology1308582601209;Context_diagram"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#configuration_is_applied_to_servers_directly -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;configuration_is_applied_to_servers_directly">
        <rdf:type rdf:resource="&Ontology1308582601209;Design_issue"/>
        <rdfs:label>Server configuration</rdfs:label>
        <status>decided</status>
        <UvA-SA-ontology:design_decision>Configuration is applied to servers directly</UvA-SA-ontology:design_decision>
        <UvA-SA-ontology:decision_issue>How to apply configuratoin to servers?</UvA-SA-ontology:decision_issue>
        <UvA-SA-ontology:name>Server configuration</UvA-SA-ontology:name>
        <UvA-SA-ontology:depends_on rdf:resource="&Ontology1308582601209;Minimum_amount_of_configuration"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#convert_data -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;convert_data">
        <rdf:type rdf:resource="&UvA-SA-ontology;Functional_requirement"/>
        <rdfs:label>convert data</rdfs:label>
        <UvA-SA-ontology:name>convert data</UvA-SA-ontology:name>
        <UvA-SA-ontology:realized_by rdf:resource="&Ontology1308582601209;Transformer_(business)"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#creation_of_multiple_front-ends -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;creation_of_multiple_front-ends">
        <rdf:type rdf:resource="&UvA-SA-ontology;Functional_requirement"/>
        <rdf:type rdf:resource="&Ontology1308582601209;Concern"/>
        <rdfs:label>creation of multiple front-ends</rdfs:label>
        <UvA-SA-ontology:description>Based on Previous’  wish, it is possible to create multiple front-ends.
Previous has yet to decide the types of front-ends they would like to use </UvA-SA-ontology:description>
        <UvA-SA-ontology:name>creation of multiple front-ends</UvA-SA-ontology:name>
        <UvA-SA-ontology:is_concern_of rdf:resource="&Ontology1308582601209;Previous"/>
        <UvA-SA-ontology:realized_by rdf:resource="&Ontology1308582601209;representation_API_"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#data_access_layer_(analysis) -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;data_access_layer_(analysis)">
        <rdf:type rdf:resource="&UvA-SA-ontology;Subsystem"/>
        <rdfs:label>data access layer (analysis)</rdfs:label>
        <UvA-SA-ontology:name>data access layer (analysis)</UvA-SA-ontology:name>
        <UvA-SA-ontology:communicates_with rdf:resource="&UvA-SA-ontology;Business_Logic_Layer"/>
        <UvA-SA-ontology:communicates_with rdf:resource="&UvA-SA-ontology;Representation_Layer"/>
        <UvA-SA-ontology:is_modeled_in rdf:resource="&UvA-SA-ontology;component_model"/>
        <UvA-SA-ontology:presented_in rdf:resource="&UvA-SA-ontology;logical_and_implementation_view"/>
        <UvA-SA-ontology:compromises_of rdf:resource="&Ontology1308582601209;Analysis_database"/>
        <UvA-SA-ontology:is_modeled_in rdf:resource="&Ontology1308582601209;Context_diagram"/>
        <UvA-SA-ontology:hosted_on rdf:resource="&Ontology1308582601209;Database_server"/>
        <UvA-SA-ontology:presented_in rdf:resource="&Ontology1308582601209;Deployment_view"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#data_access_layer_(relational) -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;data_access_layer_(relational)">
        <rdf:type rdf:resource="&UvA-SA-ontology;Subsystem"/>
        <rdfs:label>data access layer (relational)</rdfs:label>
        <UvA-SA-ontology:name>data access layer (relational)</UvA-SA-ontology:name>
        <UvA-SA-ontology:communicates_with rdf:resource="&UvA-SA-ontology;Business_Logic_Layer"/>
        <UvA-SA-ontology:is_modeled_in rdf:resource="&UvA-SA-ontology;component_model"/>
        <UvA-SA-ontology:communicates_with rdf:resource="&UvA-SA-ontology;data_layer"/>
        <UvA-SA-ontology:presented_in rdf:resource="&UvA-SA-ontology;logical_and_implementation_view"/>
        <UvA-SA-ontology:is_modeled_in rdf:resource="&Ontology1308582601209;Context_diagram"/>
        <UvA-SA-ontology:hosted_on rdf:resource="&Ontology1308582601209;Database_server"/>
        <UvA-SA-ontology:presented_in rdf:resource="&Ontology1308582601209;Deployment_view"/>
        <UvA-SA-ontology:compromises_of rdf:resource="&Ontology1308582601209;relational_database"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#data_extraction_technique_-_push_or_pull -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;data_extraction_technique_-_push_or_pull">
        <rdf:type rdf:resource="&Ontology1308582601209;Design_issue"/>
        <rdfs:label>Data extraction technique - push or pull</rdfs:label>
        <UvA-SA-ontology:design_decision>Decision: Pull data

After weighing the options, it appears that pushing the data only as a single major advantage: the fact that the critical systems can decide when they have sufficient resources available  for pushing their code to the application. 

The biggest disadvantage however, the fact that not all systems are compatible with this solution is reason enough to discard the idea. The stakeholders have said that they’re always looking for new tools that can do a better  job. If an application turns out to be incompatible with this system, not all necessary data can be used to draw conclusions regarding communication, etc. This should not be allowed to happen.
</UvA-SA-ontology:design_decision>
        <UvA-SA-ontology:decision_issue>The application consists of three layers, in which the first and second layer mutate the data delivered to them in order to pass it along to the second layer and the third layer exposes this data to the outside world (if authenticated).

Thus a method must be chosen to get data from one layer to another. This can roughly be done in two ways: push or pull.
</UvA-SA-ontology:decision_issue>
        <UvA-SA-ontology:name>data transportation technique - push or pull</UvA-SA-ontology:name>
        <status>Decided</status>
        <UvA-SA-ontology:depends_on rdf:resource="&Ontology1308582601209;Compatability"/>
        <UvA-SA-ontology:depends_on rdf:resource="&Ontology1308582601209;Criticality_of_existing_tools"/>
        <UvA-SA-ontology:depends_on rdf:resource="&Ontology1308582601209;Extensibility_of_data_sources"/>
        <UvA-SA-ontology:posit_design rdf:resource="&Ontology1308582601209;Pull_data"/>
        <UvA-SA-ontology:posit_design rdf:resource="&Ontology1308582601209;Push_data"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#data_sources_of_application_need_to_be_extensible -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;data_sources_of_application_need_to_be_extensible">
        <rdf:type rdf:resource="&Ontology1308582601209;Design_issue"/>
        <rdfs:label>Data sources of application need to be extensible</rdfs:label>
        <UvA-SA-ontology:decision_issue>By request of the  stakeholders, the data sources of the application need to be extensible. </UvA-SA-ontology:decision_issue>
        <UvA-SA-ontology:design_decision>we have made the decision to go for the partly extensible-solution after we compared the second and third scenarios. 

The partly extensible-solution is the best fit for the case of the stakeholders.</UvA-SA-ontology:design_decision>
        <UvA-SA-ontology:name>data sources of application need to be extensible</UvA-SA-ontology:name>
        <UvA-SA-ontology:depends_on rdf:resource="&Ontology1308582601209;Complexity"/>
        <UvA-SA-ontology:depends_on rdf:resource="&Ontology1308582601209;Cost"/>
        <UvA-SA-ontology:posit_design rdf:resource="&Ontology1308582601209;Current_fit_data_sources"/>
        <UvA-SA-ontology:depends_on rdf:resource="&Ontology1308582601209;Development_time"/>
        <UvA-SA-ontology:depends_on rdf:resource="&Ontology1308582601209;Extensibility_of_data_sources"/>
        <UvA-SA-ontology:depends_on rdf:resource="&Ontology1308582601209;Modifiability"/>
        <UvA-SA-ontology:posit_design rdf:resource="&Ontology1308582601209;Partly_extensible_data_sources"/>
        <UvA-SA-ontology:posit_design rdf:resource="&Ontology1308582601209;fully_extensible_data_sources"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#developer -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;developer">
        <rdf:type rdf:resource="&UvA-SA-ontology;Stakeholder"/>
        <rdfs:label>Developer</rdfs:label>
        <UvA-SA-ontology:name>Developer</UvA-SA-ontology:name>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#extractor_(business) -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;extractor_(business)">
        <rdf:type rdf:resource="&UvA-SA-ontology;Component"/>
        <rdfs:label>Extractor (business)</rdfs:label>
        <UvA-SA-ontology:name>Extractor (business)</UvA-SA-ontology:name>
        <UvA-SA-ontology:description>The extractor in the business layer is of a similar concept to the extractor at the data layer, except that this extractor is used to extract data from the relational database, which will then be used by a different transformer. A business rules engine determines which data fields the extractor should extract.</UvA-SA-ontology:description>
        <UvA-SA-ontology:part_of rdf:resource="&UvA-SA-ontology;Business_Logic_Layer"/>
        <UvA-SA-ontology:is_modeled_in rdf:resource="&UvA-SA-ontology;component_model"/>
        <UvA-SA-ontology:gathers_data rdf:resource="&Ontology1308582601209;relational_database"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#fully_extensible_data_sources -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;fully_extensible_data_sources">
        <rdf:type rdf:resource="&UvA-SA-ontology;Design_Alternatives"/>
        <rdf:type rdf:resource="&UvA-SA-ontology;Scenario"/>
        <rdfs:label>fully extensible data sources</rdfs:label>
        <status>Rejected</status>
        <UvA-SA-ontology:arguments>If we look at extensibility , we see that the fully extensible-solution is the most extensible, like the name already says. It can be fully extended with different types of data sources.

This -solution is more complex than other options, because the abstractions are at the data source level. Because of this, within the application there isn’t a structure available for types of data, in contrast to the partly extensible solution. This means that the application has to be able to handle every type of data, which raises the complexity a lot.
When the complexity of a system rises, so does the development time  because if the solution is more complex, more time goes into research, design and development. More development time means more development costs . Because of this, the complexity of the application is proportional to the cost of the application.

This solution requires a lot  of configuration to fit it to the different data sources. Data models need to be configured and the translation between the data from the data sources and the data models needs to be defined. Because of this, the deployment of this solution is the most complex. </UvA-SA-ontology:arguments>
        <UvA-SA-ontology:description>This scenario describes &#39;fully extensible data sources&#39; – Fully extensible and flexible to use every kind of source system

In this scenario, the application is built in a way that new data sources can be added regardless of type. The application provides an interface for new data sources which needs to be implemented and after that, the new data source can be plugged in. The internal structure doesn’t have to be modified for any new data sources.</UvA-SA-ontology:description>
        <UvA-SA-ontology:name>fully extensible data sources</UvA-SA-ontology:name>
        <UvA-SA-ontology:supported_by rdf:resource="&Ontology1308582601209;Data_gathering"/>
        <UvA-SA-ontology:supported_by rdf:resource="&Ontology1308582601209;fully_extensible_data_sources"/>
        <UvA-SA-ontology:based_on rdf:resource="&Ontology1308582601209;tools_will_more_frequently_change_than_tool_types."/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#layered_pattern -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;layered_pattern">
        <rdf:type rdf:resource="&Ontology1308582601209;Pattern"/>
        <rdfs:label>Layered pattern</rdfs:label>
        <UvA-SA-ontology:description>Our logical and implementation view consists of 3 layers : A data layer , a business logic  layer and a representation layer . The data layer is the layer that accommodates the gathering of data from the various project assisting tools used by Previous. The business logic layer contains the transformation of the initially gathered data to a format that is more easily accessible and analysable , which is accomplished by a set of business rules as defined by users. The representation layer contains the way of representing the results of the analysis to the users.</UvA-SA-ontology:description>
        <UvA-SA-ontology:name>Layered pattern</UvA-SA-ontology:name>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#relational_database -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;relational_database">
        <rdf:type rdf:resource="&UvA-SA-ontology;Data_store"/>
        <rdfs:label>Relational database</rdfs:label>
        <UvA-SA-ontology:name>relational database</UvA-SA-ontology:name>
        <UvA-SA-ontology:is_modeled_in rdf:resource="&UvA-SA-ontology;component_model"/>
        <UvA-SA-ontology:satisfies rdf:resource="&Ontology1308582601209;Extensibility_of_data_sources"/>
        <UvA-SA-ontology:satisfies rdf:resource="&Ontology1308582601209;Flexibility"/>
        <UvA-SA-ontology:satisfies rdf:resource="&Ontology1308582601209;Performance"/>
        <realizes rdf:resource="&Ontology1308582601209;Scheduler"/>
        <UvA-SA-ontology:satisfies rdf:resource="&Ontology1308582601209;Security"/>
        <UvA-SA-ontology:part_of rdf:resource="&Ontology1308582601209;data_access_layer_(relational)"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#representation_API_ -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;representation_API_">
        <rdf:type rdf:resource="&Ontology1308582601209;API"/>
        <rdfs:label>representation API</rdfs:label>
        <UvA-SA-ontology:description>API : The API is a web service that allows one to consult the analysis database. This API will contain a few prefixed queries that can be used for reporting purposes and also contains a free-form part, with which users can construct their own queries. This API can then be used in various client-side applications, such as a report generator or a web client.

API stands for Application Programming Interface. This is a special service or library that can be integrated within a user interface or plug-in, which can access (in our case) the data from the graph database.</UvA-SA-ontology:description>
        <UvA-SA-ontology:name>representation API</UvA-SA-ontology:name>
        <Provided_by rdf:resource="&UvA-SA-ontology;Representation_Layer"/>
        <UvA-SA-ontology:part_of rdf:resource="&UvA-SA-ontology;Representation_Layer"/>
        <UvA-SA-ontology:is_modeled_in rdf:resource="&UvA-SA-ontology;component_model"/>
        <UvA-SA-ontology:communicates_with rdf:resource="&Ontology1308582601209;Analysis_database"/>
        <UvA-SA-ontology:satisfies rdf:resource="&Ontology1308582601209;Choose_representation"/>
        <UvA-SA-ontology:satisfies rdf:resource="&Ontology1308582601209;Conformance_to_existing_security_regulations"/>
        <UvA-SA-ontology:is_modeled_in rdf:resource="&Ontology1308582601209;Deployment_diagram_-_Primary_presentation"/>
        <realizes rdf:resource="&Ontology1308582601209;Fired_query"/>
        <UvA-SA-ontology:satisfies rdf:resource="&Ontology1308582601209;Provide_Application_Programming_Interface_(API)"/>
        <UvA-SA-ontology:satisfies rdf:resource="&Ontology1308582601209;Security"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#store_data_in_flat_file_format -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;store_data_in_flat_file_format">
        <rdf:type rdf:resource="&UvA-SA-ontology;Design_Alternatives"/>
        <rdfs:label>store data in flat file format</rdfs:label>
        <UvA-SA-ontology:arguments>Advantages: No extra costs, except space + No access libs

Disadvantages:Single access, write + Bottleneck</UvA-SA-ontology:arguments>
        <status>Rejected</status>
        <UvA-SA-ontology:name>store data in flat file format</UvA-SA-ontology:name>
        <UvA-SA-ontology:description>The data collector(extractor) needs to temporary stores his extracted data, to provide them to the SNA component. The data collector can accomplish that in two ways, store them in a database or in separate flat file formats, like xml, CSV or an own simple data structure</UvA-SA-ontology:description>
        <UvA-SA-ontology:posit_design rdf:resource="&Ontology1308582601209;Store_data_in_database"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#tools_will_more_frequently_change_than_tool_types. -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;tools_will_more_frequently_change_than_tool_types.">
        <rdf:type rdf:resource="&UvA-SA-ontology;Assumption"/>
        <rdfs:label>tools will more frequently change than tool types.</rdfs:label>
        <UvA-SA-ontology:description>The stakeholders have stated that they’re always looking for new tools to do a better job, the TYPE of tools probably doesn’t change as often. For example, SVN used to be the industry standard for version control but now the industry is moving more towards decentralized versioning control systems. The implementation changes, but the general idea is still the same: it holds a record of code adaptations from one or multiple developers. This assumption has been tested with the stakeholders, and they agree.</UvA-SA-ontology:description>
        <UvA-SA-ontology:name>tools will more frequently change than tool types.</UvA-SA-ontology:name>
        <UvA-SA-ontology:made_for rdf:resource="&Ontology1308582601209;Current_fit_data_sources"/>
        <UvA-SA-ontology:made_for rdf:resource="&Ontology1308582601209;Partly_extensible_data_sources"/>
        <UvA-SA-ontology:made_for rdf:resource="&Ontology1308582601209;Periodic_listening_for_data_gathering"/>
        <UvA-SA-ontology:made_for rdf:resource="&Ontology1308582601209;Periodic_queries_for_data_gathering"/>
        <UvA-SA-ontology:made_for rdf:resource="&Ontology1308582601209;fully_extensible_data_sources"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#two_separated_servers -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;two_separated_servers">
        <rdf:type rdf:resource="&Ontology1308582601209;Design_issue"/>
        <rdfs:label>two separated servers</rdfs:label>
        <UvA-SA-ontology:name>two separated servers</UvA-SA-ontology:name>
        <UvA-SA-ontology:description>We designed the SNA system on two separate physical servers within the current network infrastructure </UvA-SA-ontology:description>
        <UvA-SA-ontology:depends_on rdf:resource="&Ontology1308582601209;Availability"/>
        <UvA-SA-ontology:based_on rdf:resource="&Ontology1308582601209;Only_a_subset_of_data_is_extracted_from_tools_"/>
    </owl:NamedIndividual>
    


    <!-- http://www.semanticweb.org/ontologies/2011/5/Ontology1308582601209.owl#user -->

    <owl:NamedIndividual rdf:about="&Ontology1308582601209;user">
        <rdf:type rdf:resource="&UvA-SA-ontology;Stakeholder"/>
        <rdfs:label>User</rdfs:label>
        <UvA-SA-ontology:description>User of the SNA system</UvA-SA-ontology:description>
        <UvA-SA-ontology:name>User</UvA-SA-ontology:name>
        <UvA-SA-ontology:communicates_with rdf:resource="&Ontology1308582601209;Configuration_Module"/>
        <UvA-SA-ontology:is_modeled_in rdf:resource="&Ontology1308582601209;Context_diagram"/>
    </owl:NamedIndividual>
</rdf:RDF>



<!-- Generated by the OWL API (version 3.2.3.1824) http://owlapi.sourceforge.net -->

